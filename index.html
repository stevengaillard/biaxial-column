<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D RC Column Interaction (Biaxial)</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22><rect width=%2264%22 height=%2264%22 fill=%22%230e7490%22/></svg>" type="image/svg+xml">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        eng: { primary: '#0e7490', secondary: '#f0f9ff', dark: '#155e75', accent: '#fbbf24' }
                    }
                }
            }
        }
    </script>
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        .input-group label { font-size: 0.85rem; font-weight: 600; color: #64748b; }
        .input-group input { font-family: 'Courier New', monospace; font-weight: bold; }
        canvas { display: block; }
        .data-table { width: 100%; border-collapse: collapse; font-size: 0.75rem; }
        .data-table th { background: #f1f5f9; padding: 4px; border: 1px solid #cbd5e1; color: #475569; font-weight: 600; }
        .data-table td { border: 1px solid #cbd5e1; padding: 0; }
        .data-table input { width: 100%; border: none; padding: 4px; text-align: center; outline: none; background: transparent; }
        .data-table input:focus { background: #f0f9ff; }
        .btn-icon { cursor: pointer; color: #94a3b8; transition: color 0.2s; }
        .btn-icon:hover { color: #dc2626; }
        .btn-add { width: 100%; padding: 4px; background: #f1f5f9; border: 1px dashed #cbd5e1; text-align: center; font-size: 0.75rem; color: #64748b; cursor: pointer; margin-top: 4px; border-radius: 4px; }
        .btn-add:hover { background: #e2e8f0; color: #0f172a; }
        .dark body { background-color: #0f172a; color: #f1f5f9; }
        .dark #sidebar { background-color: #1e293b; border-color: #334155; }
        .dark .input-group label { color: #94a3b8; }
        .dark input, .dark select, .dark textarea { 
            background-color: #334155 !important; 
            border-color: #475569 !important; 
            color: #f8fafc !important; 
        }
        .dark .bg-white { background-color: #1e293b !important; color: #e2e8f0; }
        .dark .bg-gray-50 { background-color: #0f172a !important; }
        .dark .bg-gray-100 { background-color: #1e293b !important; }
        .dark .border-gray-200, .dark .border-gray-300, .dark .border-blue-100 { border-color: #334155 !important; }
        .dark .text-slate-800 { color: #f1f5f9 !important; }
        .dark .text-gray-500, .dark .text-gray-600, .dark .text-gray-700 { color: #94a3b8 !important; }
        .dark .bg-amber-50 { background-color: #451a03 !important; border-color: #78350f !important; }
        .dark .text-amber-800 { color: #fbbf24 !important; }
        .dark .text-amber-900 { color: #fde68a !important; }
        .dark .text-blue-800 { color: #93c5fd !important; }
        .dark th { background-color: #334155 !important; color: #e2e8f0 !important; border-color: #475569 !important; }
        .dark td { border-color: #475569 !important; }
        .dark .btn-add { background-color: #334155; color: #94a3b8; border-color: #475569; }
        .dark .btn-add:hover { background-color: #475569; color: #fff; }
        .dark .absolute.bottom-4.right-4, 
        .dark .absolute.top-4.right-4 {
            background-color: rgba(30, 41, 59, 0.95) !important; 
            border-color: #475569;
            color: #f1f5f9;
        }
        .dark .absolute.bottom-4.right-4 { border-left-color: #fbbf24 !important; } 
        .dark h4.text-gray-500 { color: #94a3b8 !important; }
        .dark .text-gray-700 { color: #e2e8f0 !important; }
        .dark .text-gray-600 { color: #cbd5e1 !important; }
        .dark .text-eng-primary { color: #38bdf8 !important; } 
        .dark #safety-msg.bg-green-100 { background-color: #064e3b !important; color: #6ee7b7 !important; }
        .dark #safety-msg.bg-red-100 { background-color: #7f1d1d !important; color: #fca5a5 !important; }
        .dark #code-warnings .text-green-700 { color: #4ade80 !important; }
        .dark #code-warnings .text-red-600 { color: #f87171 !important; }
        .dark #code-warnings .text-amber-600 { color: #fbbf24 !important; }
        .dark #code-warnings .text-gray-400 { color: #94a3b8 !important; }
        .dark #code-warnings .border-b { border-color: #334155 !important; }
        #print-staging { display: none; }
        @media print {
            @page { size: A4; margin: 15mm; }
            body > nav, 
            body > div.flex { display: none !important; }
            #print-staging { 
                display: block !important; 
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                background: white;
                color: black;
                font-family: 'Segoe UI', sans-serif;
                font-size: 10pt;
            }
            .rpt-header {
                display: flex; justify-content: space-between; align-items: flex-end;
                border-bottom: 2px solid #0e7490; padding-bottom: 10px; margin-bottom: 20px;
            }
            .rpt-title { color: #0e7490; font-size: 18pt; font-weight: bold; margin: 0; }
            .rpt-subtitle { font-size: 10pt; color: #555; margin: 2px 0 0 0; }
            h3 { 
                color: #1e293b; font-size: 12pt; margin-top: 20px; margin-bottom: 10px; 
                background: #f1f5f9; padding: 5px 10px; font-weight: bold; border-left: 4px solid #0e7490;
            }
            table { width: 100%; border-collapse: collapse; margin-bottom: 15px; font-size: 9pt; }
            th { background-color: #0e7490; color: white; padding: 6px; text-align: left; font-weight: bold; }
            td { border: 1px solid #cbd5e1; padding: 6px; vertical-align: middle; }
            tr:nth-child(even) { background-color: #f8fafc; }
            .pass { color: #15803d; font-weight: bold; }
            .fail { color: #dc2626; font-weight: bold; }
            .warn { color: #d97706; font-weight: bold; }
            .page-break { break-before: page; }
        }
    </style>
</head>
<!-- REPLACE the <nav> and the opening of the main container div with this: -->
<body class="bg-gray-100 text-slate-800 h-screen flex flex-col overflow-hidden">
    <nav class="bg-eng-primary text-white shadow-lg z-50">
        <div class="max-w-7xl mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center gap-3">
                <button onclick="toggleSidebar()" class="text-white hover:text-eng-accent focus:outline-none">
                    <i class="fa-solid fa-bars text-xl"></i>
                </button>
                <i class="fa-solid fa-cube text-2xl text-eng-accent"></i>
                <div>
                    <h1 class="font-bold text-lg leading-tight" data-i18n="app_title">RC Column 3D Interaction</h1>
                    <p class="text-xs opacity-80 font-light" data-i18n="app_desc">Biaxial Bending Capacity (Taiwan Code 112)</p>
                </div>
            </div>
            <div id="auth-section" class="flex items-center gap-2">
                <button onclick="toggleHistoryModal()" class="text-white/80 hover:text-white px-2 transition" title="Database">
                    <i class="fa-solid fa-database"></i>
                </button>
                <button onclick="toggleWireframe()" class="bg-gray-100/80 hover:bg-gray-200/80 text-gray-700 backdrop-blur-sm border border-gray-300 px-3 py-1.5 rounded text-xs font-bold transition">
                    <i class="fa-solid fa-border-all mr-2"></i><span data-i18n="btn_wireframe">Wireframe</span>
                </button>
                <button onclick="toggleDarkMode()" class="bg-blue-800 hover:bg-blue-700 text-white px-3 py-1.5 rounded text-xs font-bold border border-blue-600 transition">
                        <i id="dark-icon" class="fa-solid fa-moon"></i>
                </button>
                <button onclick="toggleLanguage()" class="bg-eng-dark hover:bg-cyan-800 text-white px-3 py-1.5 rounded text-xs font-bold border border-cyan-600 transition flex items-center">
                    <i class="fa-solid fa-language mr-1"></i> <span id="lang-label">中文</span>
                </button>
                <button id="login-btn" onclick="openAuthModal()" class="bg-white text-eng-primary px-4 py-1.5 rounded text-sm font-bold shadow hover:bg-gray-100 transition">
                    <i class="fa-solid fa-user mr-2"></i><span data-i18n="btn_login">Login</span>
                </button>
                <div id="user-info" class="hidden flex items-center space-x-3">
                    <span id="user-email" class="text-xs opacity-90 hidden sm:inline font-mono bg-eng-dark px-2 py-1 rounded border border-cyan-600"></span>
                    <button onclick="auth.signOut()" class="text-sm hover:text-red-300 transition" title="Logout">
                        <i class="fa-solid fa-right-from-bracket"></i>
                    </button>
                </div>
            </div>
        </div>
    </nav>
    <!-- Auth Modal -->
    <div id="auth-modal" class="fixed inset-0 bg-slate-900 bg-opacity-70 flex items-center justify-center z-50 hidden backdrop-blur-sm">
        <div class="bg-white rounded-lg shadow-2xl p-8 w-11/12 max-w-sm border-t-4 border-eng-primary">
            <h2 class="text-2xl font-bold mb-2 text-center text-eng-primary" data-i18n="modal_title">Access Portal</h2>
            <p class="text-gray-500 mb-4 text-center text-sm" data-i18n="modal_desc">Sign in to sync your data across devices.</p>
            <div class="space-y-3 mb-4">
                <input type="email" id="auth-email" placeholder="Email" class="w-full border rounded p-2 text-sm focus:ring-2 focus:ring-eng-primary outline-none">
                <input type="password" id="auth-password" placeholder="Password" class="w-full border rounded p-2 text-sm focus:ring-2 focus:ring-eng-primary outline-none">
            </div>
            <div class="flex gap-2 mb-4">
                <button id="email-login-btn" class="flex-1 bg-eng-primary text-white py-2 rounded text-sm font-bold hover:bg-blue-800 transition" data-i18n="btn_login_submit">Login</button>
                <button id="email-register-btn" class="flex-1 bg-white text-eng-primary border border-eng-primary py-2 rounded text-sm font-bold hover:bg-blue-50 transition" data-i18n="btn_register">Register</button>
            </div>
            <div class="relative flex py-2 items-center">
                <div class="flex-grow border-t border-gray-300"></div>
                <span class="flex-shrink mx-4 text-gray-400 text-xs">OR</span>
                <div class="flex-grow border-t border-gray-300"></div>
            </div>
            <button id="guest-login" class="w-full bg-gray-200 text-gray-700 py-2 rounded mb-3 text-sm font-semibold hover:bg-gray-300 transition shadow-sm" data-i18n="btn_guest">
                Continue as Guest
            </button>
            <p id="auth-error" class="text-xs text-red-500 text-center hidden mt-2"></p>
        </div>
    </div>
    <!-- Main Content Container (Flex Row: Sidebar Left, 3D Right) -->
    <div class="flex flex-1 overflow-hidden relative">
        <!-- Sidebar -->
        <div id="sidebar" class="w-96 bg-white border-r border-gray-200 overflow-y-auto flex-shrink-0 z-40 shadow-md transition-all duration-300 ease-in-out transform translate-x-0">
            <div class="p-4 space-y-6">
                <!-- 1. Section Geometry -->
                <div class="space-y-3">
                    <h3 class="text-sm font-bold text-eng-primary border-b pb-1" data-i18n="sec_geo">1. Section Geometry</h3>
                    <!-- Shape Selector -->
                    <div class="mb-2">
                        <label class="text-xs font-bold text-gray-500 block mb-1" data-i18n="lbl_shape">Section Shape</label>
                        <select id="col_shape" class="w-full border border-gray-300 rounded p-1.5 text-sm" onchange="toggleShapeInputs()">
                            <option value="rect" data-i18n="opt_rect">Rectangular</option>
                            <option value="circ" data-i18n="opt_circ">Circular</option>
                        </select>
                    </div>
                    <div class="grid grid-cols-2 gap-3">
                        <div class="input-group">
                            <label id="lbl_dim1" data-i18n="lbl_width">Width b (cm)</label>
                            <input type="number" id="col_b" value="60" min="20" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm focus:ring-2 focus:ring-eng-primary outline-none" oninput="updateApp()">
                        </div>
                        <div id="div_dim2" class="input-group">
                            <label data-i18n="lbl_depth">Depth h (cm)</label>
                            <input type="number" id="col_h" value="60" min="20" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm focus:ring-2 focus:ring-eng-primary outline-none" oninput="updateApp()">
                        </div>
                    </div>
                    <div class="input-group mt-2">
                        <label data-i18n="lbl_cover">Clear Cover (cm)</label>
                        <input type="number" id="col_cover" value="4.0" min="4.0" max="15.0" step="0.1" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm focus:ring-2 focus:ring-eng-primary outline-none" oninput="updateApp()">
                    </div>
                    <div class="input-group mt-2">
                        <label data-i18n="lbl_lu">Unbraced Length Lu (m)</label>
                        <input type="number" id="col_lu" value="3.0" min="0.1" step="0.1" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm focus:ring-2 focus:ring-eng-primary outline-none" oninput="updateApp()">
                    </div>
                </div>
                <!-- 2. Materials -->
                <div class="space-y-3">
                    <h3 class="text-sm font-bold text-eng-primary border-b pb-1" data-i18n="sec_mat">2. Materials</h3>
                    <div class="grid grid-cols-2 gap-3">
                        <div class="input-group">
                            <label data-i18n="lbl_fc">Concrete f'c (kgf/cm²)</label>
                            <input type="number" id="mat_fc" value="280" min="140" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm text-blue-700" oninput="updateApp()">
                        </div>
                        <div class="input-group">
                            <label data-i18n="lbl_fy">Steel fy (kgf/cm²)</label>
                            <input type="number" id="mat_fy" value="4200" min="2800" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm text-red-700" oninput="updateApp()">
                        </div>
                    </div>
                </div>
                <!-- 3. Reinforcement -->
                <div class="space-y-3">
                    <h3 class="text-sm font-bold text-eng-primary border-b pb-1" data-i18n="sec_rebar">3. Reinforcement</h3>
                    <div class="flex gap-2 mb-2 text-xs">
                        <label class="flex items-center"><input type="radio" name="rebar_mode" value="regular" checked onchange="toggleRebarMode()"> <span class="ml-1" data-i18n="lbl_reg">Regular</span></label>
                        <label class="flex items-center"><input type="radio" name="rebar_mode" value="custom" onchange="toggleRebarMode()"> <span class="ml-1" data-i18n="lbl_cust">Custom</span></label>
                    </div>
                    <div id="rebar-regular">
                        <div class="input-group">
                            <label data-i18n="lbl_size">Rebar Size (Ab)</label>
                            <select id="bar_size" class="w-full border border-gray-300 rounded p-1.5 text-sm mb-2" onchange="updateApp()">
                                <option value="1.27">D13 (1.27 cm²)</option>
                                <option value="1.98">D16 (1.98 cm²)</option>
                                <option value="2.87">D19 (2.87 cm²)</option>
                                <option value="3.87">D22 (3.87 cm²)</option>
                                <option value="5.07" selected>D25 (5.07 cm²)</option>
                                <option value="6.42">D29 (6.42 cm²)</option>
                                <option value="7.94">D32 (7.94 cm²)</option>
                                <option value="9.57">D36 (9.57 cm²)</option>
                            </select>
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div class="input-group" id="lbl_nz_container">
                                <label data-i18n="lbl_nz">Top/Bot (ny)</label>
                                <input type="number" id="nz_bars" value="4" min="2" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm" oninput="updateApp()">
                            </div>
                            <div class="input-group" id="lbl_nx_container">
                                <label data-i18n="lbl_nx">Side (nz)</label>
                                <input type="number" id="nx_bars" value="4" min="2" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm" oninput="updateApp()">
                            </div>
                            <div class="input-group hidden col-span-2" id="lbl_ntotal_container">
                                <label data-i18n="lbl_n_total">Total Bars (n)</label>
                                <input type="number" id="n_circ_bars" value="8" min="4" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm" oninput="updateApp()">
                            </div>
                        </div>
                    </div>
                    <div id="rebar-custom" class="hidden">
                        <label class="text-xs font-bold text-gray-500 mb-1 block" data-i18n="lbl_cust_layout">Custom Layout (y, z, db)</label>
                        <button class="w-full bg-eng-secondary text-eng-dark border border-eng-primary text-xs font-bold py-1.5 px-2 rounded mb-2 hover:bg-eng-primary hover:text-white transition" onclick="importRegularToCustom()">
                            <i class="fa-solid fa-file-import mr-1"></i> <span data-i18n="btn_gen">Generate</span>
                        </button>
                        <details class="text-xs mb-2">
                            <summary class="cursor-pointer text-gray-500 hover:text-eng-primary" data-i18n="sum_paste">Paste Coordinates</summary>
                            <textarea id="paste_rebar" placeholder="Copy columns: z  y  db(cm)" class="w-full h-16 border rounded p-1 text-[10px] font-mono mt-1"></textarea>
                            <button onclick="parseCustomRebar()" class="w-full bg-white border border-gray-300 hover:bg-gray-100 text-gray-700 px-2 py-1 rounded mt-1" data-i18n="btn_load_rebar">Load Rebar</button>
                        </details>
                        <table class="data-table" id="table-rebar">
                            <thead>
                                <tr>
                                    <th data-i18n="th_x">y (cm)</th>
                                    <th data-i18n="th_y">z (cm)</th>
                                    <th data-i18n="th_db">db (cm)</th>
                                    <th style="width: 20px;"></th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <button class="btn-add" onclick="addRebarRow()">
                            <i class="fa-solid fa-plus mr-1"></i> <span data-i18n="btn_add_bar">Add Bar</span>
                        </button>
                    </div>
                </div>
                <!-- 4. Loads -->
                <div class="space-y-3 bg-gray-50 p-3 rounded border border-gray-200">
                    <div class="flex justify-between items-center border-b pb-1 border-red-200">
                        <h3 class="text-sm font-bold text-red-600" data-i18n="sec_loads">4. Factored Loads</h3>
                    </div>
                    <div class="grid grid-cols-2 gap-2 mb-2">
                        <div class="input-group flex flex-col bg-white p-2 rounded border border-blue-100">
                            <label class="text-blue-800 text-xs" data-i18n="lbl_vux">Global Vuy (tf)</label>
                            <input type="number" id="global_vux" value="5" class="w-full border border-blue-300 rounded p-1 text-right text-sm font-bold text-blue-700 bg-blue-50" oninput="updateApp()">
                        </div>
                        <div class="input-group flex flex-col bg-white p-2 rounded border border-blue-100">
                            <label class="text-blue-800 text-xs" data-i18n="lbl_vuy">Global Vuz (tf)</label>
                            <input type="number" id="global_vuy" value="5" class="w-full border border-blue-300 rounded p-1 text-right text-sm font-bold text-blue-700 bg-blue-50" oninput="updateApp()">
                        </div>
                    </div>
                    <details class="text-xs mb-2">
                        <summary class="cursor-pointer text-gray-500 hover:text-eng-primary" data-i18n="sum_paste_load">Batch Paste (Excel)</summary>
                        <textarea id="paste_loads" placeholder="Copy columns from Excel: Pu  Muy  Muz" class="w-full h-16 border rounded p-1 text-[10px] font-mono mt-1"></textarea>
                        <button onclick="parseLoads()" class="w-full bg-white border border-gray-300 hover:bg-gray-100 text-gray-700 px-2 py-1 rounded mt-1" data-i18n="btn_load_data">Load Data</button>
                    </details>
                    <div class="mt-2 max-h-40 overflow-y-auto">
                        <table class="data-table" id="table-loads">
                            <thead class="sticky top-0 bg-gray-100 z-10 shadow-sm">
                                <tr>
                                    <th class="text-red-700" data-i18n="th_pu">Pu (tf)</th>
                                    <th class="text-red-700" data-i18n="th_mux">Muy (tf-m)</th>
                                    <th class="text-red-700" data-i18n="th_muy">Muz (tf-m)</th>
                                    <th style="width: 20px;"></th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <button class="btn-add" onclick="addLoadRow()">
                        <i class="fa-solid fa-plus mr-1"></i> <span data-i18n="btn_add_case">Add Load Case</span>
                    </button>
                </div>
                <!-- 5. Shear -->
                <div class="space-y-3">
                    <h3 class="text-sm font-bold text-eng-primary border-b pb-1" data-i18n="sec_shear">5. Shear Design (Vu)</h3>
                    <div class="mb-2 mt-1">
                        <label class="flex items-center text-xs font-bold text-amber-700 cursor-pointer">
                            <input type="checkbox" id="seismic_mode" class="mr-2" onchange="updateApp()">
                            <span data-i18n="lbl_seismic">Seismic (Special Moment Frame)</span>
                        </label>
                    </div>
                    <div class="grid grid-cols-2 gap-3">
                            <div class="input-group">
                                <label data-i18n="lbl_tie_db">Tie Diameter db (cm)</label>
                                <input type="number" id="shear_db" value="1.3" min="1.0" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm" oninput="updateApp()">
                            </div>
                            <div class="input-group">
                                <label data-i18n="lbl_tie_s">Tie Spacing s (cm)</label>
                                <input type="number" id="shear_s" value="10" min="3.0" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm" oninput="updateApp()">
                            </div>
                            <div class="input-group shear-rect">
                                <label data-i18n="lbl_leg_x"># Legs Z-dir</label>
                                <input type="number" id="shear_nz" value="2" min="2" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm" oninput="updateApp()">
                            </div>
                            <div class="input-group shear-rect">
                                <label data-i18n="lbl_leg_y"># Legs X-dir</label>
                                <input type="number" id="shear_nx" value="2" min="2" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm" oninput="updateApp()">
                            </div>
                            <div class="input-group shear-circ hidden col-span-2">
                                <div class="flex gap-4 mb-2 mt-1 text-xs font-bold text-gray-600 border-b border-gray-200 pb-2">
                                    <label class="flex items-center cursor-pointer">
                                        <input type="radio" name="circ_type" value="hoop" checked onchange="updateApp()"> 
                                        <span class="ml-1" data-i18n="lbl_hoop">Hoop (Normal)</span>
                                    </label>
                                    <label class="flex items-center cursor-pointer">
                                        <input type="radio" name="circ_type" value="spiral" onchange="updateApp()"> 
                                        <span class="ml-1" data-i18n="lbl_spiral">Spiral</span>
                                    </label>
                                </div>
                                <label data-i18n="lbl_legs_circ">Shear Legs (Total)</label>
                                <input type="number" id="shear_legs_circ" value="2" min="2" step="1" class="w-full border border-gray-300 rounded p-1.5 text-right text-sm" oninput="updateApp()">
                            </div>
                        </div>
                </div>
                <button id="save-btn" onclick="saveToCloud()" class="w-full bg-green-600 hover:bg-green-700 text-white text-sm font-bold py-2 px-4 rounded shadow transition flex items-center justify-center gap-2">
                <i class="fa-solid fa-cloud-arrow-up"></i> <span data-i18n="btn_save">Save to Cloud</span>
            </button>
            <div class="mt-2">
                <label class="text-xs font-bold text-gray-500 mb-1 block" data-i18n="lbl_app_opt">Report Appendix</label>
                <select id="rpt_appendix" class="w-full border border-gray-300 rounded p-1.5 text-sm mb-2">
                    <option value="none" data-i18n="opt_app_none">None (Summary Only)</option>
                    <option value="summary" selected data-i18n="opt_app_sum">Summary (3D + Top 5 Cuts)</option>
                    <option value="full" data-i18n="opt_app_full">Full (3D + All Cuts)</option>
                </select>
            </div>
            <button onclick="printReport()" class="w-full bg-slate-700 hover:bg-slate-800 text-white text-sm font-bold py-2 px-4 rounded shadow transition flex items-center justify-center gap-2">
                <i class="fa-solid fa-print"></i> <span data-i18n="btn_gen_rpt">Generate Summary Report</span>
            </button>
            </div>
        </div>
        <!-- 3D Visualization Area -->
        <div class="flex-1 flex flex-col min-w-0 bg-white relative">
            <div id="container-3d" class="flex-1 w-full h-full cursor-move"></div>
            <!-- Legend / Overlay -->
            <div id="ui-legend" class="absolute bottom-4 right-4 bg-white/95 backdrop-blur p-5 rounded shadow-xl w-80 border-l-4 border-eng-primary ring-1 ring-gray-200">
                <div class="flex gap-3 mb-3 text-[10px] uppercase font-bold tracking-wider">
                    <div class="flex items-center"><span class="w-3 h-3 rounded-full bg-gray-300 border border-gray-400 mr-1 opacity-50"></span> <span data-i18n="leg_nom">Nominal (Pn)</span></div>
                    <div class="flex items-center"><span class="w-3 h-3 rounded-full bg-eng-primary mr-1 opacity-80"></span> <span data-i18n="leg_des">Design (ϕPn)</span></div>
                </div>
                <hr class="border-gray-200 mb-2">
                <h4 class="text-xs font-bold text-gray-500 uppercase mb-2" data-i18n="tit_check">Safety Check (D/C Ratio)</h4>
                <div class="flex justify-between items-baseline mb-1">
                    <span class="text-sm font-bold text-gray-700" data-i18n="lbl_coord">Coordinates:</span>
                </div>
                <div class="text-xs font-mono text-gray-600 mb-3 space-y-1">
                    <div class="flex justify-between"><span>Pu:</span> <span><span id="disp_pu"></span> tf</span></div>
                    <div class="flex justify-between"><span>Muy:</span> <span><span id="disp_mux"></span> tf-m</span></div>
                    <div class="flex justify-between"><span>Muz:</span> <span><span id="disp_muy"></span> tf-m</span></div>
                </div>
                <h4 class="text-xs font-bold text-gray-500 uppercase mb-1" data-i18n="tit_max">Max Design Capacity</h4>
                <div class="text-[10px] font-mono text-eng-primary mb-3 space-y-1 border-b pb-2">
                    <div class="flex justify-between"><span>ϕPn(max):</span> <span><span id="max_phi_pn"></span> tf</span></div>
                    <div class="flex justify-between"><span>ϕMny(max):</span> <span><span id="max_phi_mnz"></span> tf-m</span></div>
                    <div class="flex justify-between"><span>ϕMnz(max):</span> <span><span id="max_phi_mnx"></span> tf-m</span></div>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-4 mb-1 overflow-hidden relative">
                    <div id="dc-bar" class="bg-eng-primary h-4 rounded-full transition-all duration-500" style="width: 0%"></div>
                </div>
                <div class="flex justify-between items-center">
                    <span class="text-xs text-gray-500" data-i18n="lbl_ratio">Capacity Ratio</span>
                    <span id="dc-val" class="text-lg font-bold text-eng-primary">0.00</span>
                </div>
                <div id="safety-msg" class="text-center text-xs font-bold mt-2 py-1 rounded bg-green-100 text-green-700">
                    SAFE
                </div>
                <div id="code-warnings" class="text-[10px] font-mono mt-2 space-y-1 text-red-600 font-bold hidden"></div>
            </div>
            <div id="ui-section" class="absolute top-4 right-4 bg-white p-3 rounded shadow-lg border border-gray-200">
                <canvas id="section-canvas" width="120" height="120"></canvas>
                <p class="text-[10px] text-center text-gray-400 mt-1 uppercase font-bold" data-i18n="lbl_sec_view">Section View</p>
            </div>
        </div>
    </div>
    <div id="print-staging"></div>
    <div id="history-modal" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center backdrop-blur-sm">
        <div class="bg-white rounded-lg shadow-xl w-96 max-h-[80vh] flex flex-col">
            <div class="p-3 border-b flex justify-between items-center bg-gray-50 rounded-t-lg">
                <h3 class="font-bold text-gray-700"><i class="fa-solid fa-database mr-2"></i>Saved Designs</h3>
                <button onclick="toggleHistoryModal()" class="text-gray-400 hover:text-red-500"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div id="history-list" class="flex-1 overflow-y-auto p-2 space-y-2 bg-gray-50">
                <div class="text-center text-xs text-gray-400 py-4">No records found.</div>
            </div>
        </div>
    </div>
    <script>
        let scene, camera, renderer, controls;
        let isDarkMode = false;
        let pmnMesh;
        let loadPointsGroup = new THREE.Group(); 
        let limitGroup = new THREE.Group(); 
        let isWireframe = false;
        let vizScales = { p: 1, m: 1 };
        const firebaseConfig = {
            apiKey: "AIzaSyBaORYlb0hpZgAix13QBF71rVGPLo2NI7E",
            authDomain: "column-app-6d9bd.firebaseapp.com",
            projectId: "column-app-6d9bd",
            storageBucket: "column-app-6d9bd.firebasestorage.app",
            messagingSenderId: "840460637049",
            appId: "1:840460637049:web:63895a5995d0fbe8fbd5a8",
            measurementId: "G-DJ5RDVJYW7"
        };
        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        let currentUser = null;
        document.getElementById('email-login-btn').addEventListener('click', async () => {
            const email = document.getElementById('auth-email').value;
            const password = document.getElementById('auth-password').value;
            const errorMsg = document.getElementById('auth-error');
            errorMsg.classList.add('hidden');
            if (!email || !password) {
                errorMsg.innerText = "Please enter both email and password.";
                errorMsg.classList.remove('hidden');
                return;
            }
            try {
                await auth.signInWithEmailAndPassword(email, password);
                closeAuthModal();
            } catch (e) {
                errorMsg.innerText = e.message;
                errorMsg.classList.remove('hidden');
            }
        });
        document.getElementById('email-register-btn').addEventListener('click', async () => {
            const email = document.getElementById('auth-email').value;
            const password = document.getElementById('auth-password').value;
            const errorMsg = document.getElementById('auth-error');
            errorMsg.classList.add('hidden');
            if (!email || !password) {
                errorMsg.innerText = "Please enter both email and password.";
                errorMsg.classList.remove('hidden');
                return;
            }
            try {
                await auth.createUserWithEmailAndPassword(email, password);
                closeAuthModal();
            } catch (e) {
                errorMsg.innerText = e.message;
                errorMsg.classList.remove('hidden');
            }
        });
        document.getElementById('guest-login').addEventListener('click', async () => {
            try {
                await auth.signInAnonxmously();
                closeAuthModal();
            } catch (e) {
                console.error(e);
            }
        });
        function openAuthModal() {
            document.getElementById('auth-modal').classList.remove('hidden');
        }
        function closeAuthModal() {
            document.getElementById('auth-modal').classList.add('hidden');
        }
        function handleGoogleAuth() {
            const provider = new firebase.auth.GoogleAuthProvider();
            auth.signInWithPopup(provider)
                .then(() => closeAuthModal())
                .catch(e => alert(e.message));
        }
        auth.onAuthStateChanged(user => {
            currentUser = user;
            const loginBtn = document.getElementById('login-btn');
            const userInfo = document.getElementById('user-info');
            const userEmail = document.getElementById('user-email');
            if (user) {
                loginBtn.classList.add('hidden');
                userInfo.classList.remove('hidden');
                userEmail.innerText = user.email || "User";
                loadHistory(); 
            } else {
                loginBtn.classList.remove('hidden');
                userInfo.classList.add('hidden');
                document.getElementById('history-list').innerHTML = '<div class="text-center text-xs text-gray-400 py-4">Please login to view history.</div>';
            }
        });
        function handleAuth() {
            const provider = new firebase.auth.GoogleAuthProvider();
            auth.signInWithPopup(provider).catch(e => alert(e.message));
        }
        async function saveToCloud() {
            if (!currentUser) return alert("Please login to save.");
            const state = {
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                inputs: {
                    b: document.getElementById('col_b').value,
                    h: document.getElementById('col_h').value,
                    fc: document.getElementById('mat_fc').value,
                    fy: document.getElementById('mat_fy').value,
                    pu: document.getElementById('disp_pu').innerText,
                    dc: document.getElementById('dc-val').innerText,
                    status: document.getElementById('safety-msg').innerText
                },
                fullData: {
                      col_b: document.getElementById('col_b').value,
                      col_h: document.getElementById('col_h').value,
                      col_shape: document.getElementById('col_shape').value, 
                      col_cover: document.getElementById('col_cover').value,
                      mat_fc: document.getElementById('mat_fc').value,
                      mat_fy: document.getElementById('mat_fy').value,
                      col_lu: document.getElementById('col_lu').value,
                      bar_size: document.getElementById('bar_size').value,
                      nz_bars: document.getElementById('nz_bars').value,
                      nx_bars: document.getElementById('nx_bars').value,
                      n_circ_bars: document.getElementById('n_circ_bars').value,
                      shear_legs_circ: document.getElementById('shear_legs_circ').value,
                      shear_s: document.getElementById('shear_s').value,
                      shear_db: document.getElementById('shear_db').value,
                      shear_nz: document.getElementById('shear_nz').value,
                      shear_nx: document.getElementById('shear_nx').value
                }
            };
            try {
                await db.collection('users').doc(currentUser.uid).collection('rc_designs').add(state);
                alert("Design saved to cloud!");
                loadHistory(); 
            } catch (e) {
                console.error(e);
                alert("Save failed.");
            }
        }
        function toggleShapeInputs() {
            const shape = document.getElementById('col_shape').value;
            const dim2 = document.getElementById('div_dim2');
            const lbl1 = document.getElementById('lbl_dim1');
            const rectShear = document.querySelectorAll('.shear-rect');
            const circShear = document.querySelector('.shear-circ');
            if (shape === 'circ') {
                dim2.classList.add('hidden');
                lbl1.innerText = currentLang === 'zh' ? "直徑 D (cm)" : "Diameter D (cm)";
                document.getElementById('lbl_nz_container').classList.add('hidden');
                document.getElementById('lbl_nx_container').classList.add('hidden');
                document.getElementById('lbl_ntotal_container').classList.remove('hidden');
                rectShear.forEach(el => el.classList.add('hidden'));
                circShear.classList.remove('hidden');
            } else {
                dim2.classList.remove('hidden');
                lbl1.innerText = t('lbl_width');
                document.getElementById('lbl_nz_container').classList.remove('hidden');
                document.getElementById('lbl_nx_container').classList.remove('hidden');
                document.getElementById('lbl_ntotal_container').classList.add('hidden');
                rectShear.forEach(el => el.classList.remove('hidden'));
                circShear.classList.add('hidden');
            }
            updateApp();
        }
        function toggleHistoryModal() {
            const m = document.getElementById('history-modal');
            m.classList.toggle('hidden');
        }
        function loadHistory() {
            if (!currentUser) return;
            const list = document.getElementById('history-list');
            list.innerHTML = '<div class="text-center text-xs text-gray-400"><i class="fa-solid fa-spinner fa-spin"></i> Loading...</div>';
            db.collection('users').doc(currentUser.uid).collection('rc_designs')
              .orderBy('timestamp', 'desc').limit(20)
              .get().then(snap => {
                  if (snap.empty) {
                      list.innerHTML = '<div class="text-center text-xs text-gray-400 py-4">No records found.</div>';
                      return;
                  }
                  let html = '';
                  snap.forEach(doc => {
                      const d = doc.data();
                      const date = d.timestamp ? new Date(d.timestamp.seconds * 1000).toLocaleDateString() : '?';
                      const color = d.inputs.status.includes('SAFE') ? 'text-green-600' : 'text-red-600';
                      html += `
                        <div class="bg-white p-2 rounded border border-gray-200 shadow-sm hover:shadow-md transition cursor-pointer" onclick='restoreDesign(${JSON.stringify(d.fullData)})'>
                            <div class="flex justify-between items-center mb-1">
                                <span class="font-bold text-xs text-gray-700">${d.inputs.b}x${d.inputs.h} cm</span>
                                <span class="text-[10px] text-gray-400">${date}</span>
                            </div>
                            <div class="flex justify-between items-center text-[10px]">
                                <span class="text-gray-500">Pu: ${d.inputs.pu} tf</span>
                                <span class="${color} font-bold">D/C: ${d.inputs.dc}</span>
                            </div>
                             <div class="flex justify-end mt-1">
                                <button onclick="deleteDesign('${doc.id}', event)" class="text-[10px] text-red-400 hover:text-red-600"><i class="fa-solid fa-trash"></i></button>
                            </div>
                        </div>
                      `;
                  });
                  list.innerHTML = html;
              });
        }
        function restoreDesign(data) {
            if(!data) return;
            for (const [key, val] of Object.entries(data)) {
                const el = document.getElementById(key);
                if (el) el.value = val;
            }
            updateApp();
            toggleHistoryModal();
        }
        function deleteDesign(id, e) {
            e.stopPropagation(); 
            if(!confirm("Delete this record?")) return;
            db.collection('users').doc(currentUser.uid).collection('rc_designs').doc(id).delete()
              .then(() => loadHistory());
        }
        let currentLang = 'en'; 
        const translations = {
            en: {
                lbl_shape: "Section Shape",
                opt_rect: "Rectangular",
                opt_circ: "Circular",
                lbl_n_total: "Total Bars (n)",
                modal_title: "Access Portal",
                modal_desc: "Sign in to sync your data across devices.",
                btn_login_submit: "Login",
                btn_login: "Login",
                btn_logout: "Logout",
                btn_register: "Register",
                btn_guest: "Continue as Guest",
                app_title: "RC Column 3D Interaction",
                app_desc: "Biaxial Bending Capacity (Taiwan Code 112)",
                status_ready: "READY",
                opt_title: "Optimizer",
                opt_lock: "Check properties to <b>LOCK</b> (Keep unchanged):",
                lbl_lock_dim: "B & H", lbl_lock_mat: "Mat.", lbl_lock_bar: "Rebar",
                btn_opt: "Auto-Design Section",
                w_reinf_ratio: "✓ Rebar Ratio",
                w_tie_spacing: "✓ Tie Spacing",
                rule_gravity: "Gravity (16db, dim)",
                rule_seismic: "Seismic (d/4, 6db, 15cm)",
                btn_wireframe: "Wireframe Mode",
                lbl_sec_view: "Section View",
                btn_save: "Save to Cloud",
                btn_saving: "Saving...",
                btn_saved: "Saved!",
                val_mode_regular: "Regular Layout",
                val_mode_custom: "Custom Config",
                val_ok: "Compliant",
                sec_geo: "1. Section Geometry",
                lbl_width: "Width b (cm)", lbl_depth: "Depth h (cm)",
                lbl_cover: "Clear Cover (cm)", lbl_lu: "Unbraced Length Lu (m)",
                sec_mat: "2. Materials",
                lbl_fc: "Concrete f'c (kgf/cm²)", lbl_fy: "Steel fy (kgf/cm²)",
                sec_rebar: "3. Reinforcement",
                lbl_reg: "Regular", lbl_cust: "Custom",
                lbl_size: "Rebar Size (Ab)",
                lbl_nz: "Top/Bot (ny)", lbl_nx: "Side (nz)",
                lbl_cust_layout: "Custom Layout (y, z, db)",
                btn_gen: "Generate from Regular Config",
                sum_paste: "Paste Coordinates",
                ph_paste_rebar: "Copy columns:\nz  y  db(cm)",
                btn_load_rebar: "Load Rebar",
                th_x: "y (cm)", th_y: "z (cm)", th_db: "db (cm)",
                btn_add_bar: "Add Bar",
                sec_loads: "4. Factored Loads",
                lbl_vux: "Global Vuy (tf)", lbl_vuy: "Global Vuz (tf)",
                sum_paste_load: "Batch Paste (Excel)",
                ph_paste_load: "Copy columns from Excel:\nPu  Muy  Muz",
                btn_load_data: "Load Data",
                th_pu: "Pu (tf)", th_mux: "Muy (tf-m)", th_muy: "Muz (tf-m)",
                btn_add_case: "Add Load Case",
                sec_shear: "5. Shear Design (Vu)",
                lbl_seismic: "Seismic (Special Moment Frame)",
                lbl_hoop: "Hoop (Normal)",
                lbl_spiral: "Spiral",
                lbl_app_opt: "Appendix Options",
                opt_app_none: "None (Summary Only)",
                opt_app_sum: "Summary (3D + Top 5 Cuts)",
                opt_app_full: "Full (3D + All Cuts)",
                rpt_app_title: "Appendix: Interaction Diagrams",
                rpt_3d_view: "3D Interaction Surface",
                rpt_slice_view: "2D Interaction Slice (Cut)",
                rpt_case: "Load Case",
                rpt_angle: "Load Angle",
                lbl_tie_db: "Tie Diameter db (cm)", lbl_tie_s: "Tie Spacing s (cm)",
                lbl_leg_x: "# Legs Y-dir", lbl_leg_y: "# Legs Z-dir",
                lbl_legs_circ: "Shear Legs (Total)",
                rpt_res: "Resultant",
                leg_nom: "Nominal (Pn)", leg_des: "Design (ϕPn)",
                tit_check: "Safety Check (D/C Ratio)",
                lbl_coord: "Coordinates:",
                tit_max: "Max Design Capacity",
                lbl_ratio: "Capacity Ratio",
                sts_safe: "SAFE", sts_fail: "FAILURE", sts_shear: "SHEAR FAILURE",
                rpt_title: "RC Column Analysis Report",
                rpt_sub: "Biaxial Interaction & Shear Design (Taiwan Code 112)",
                rpt_sec1: "1. Section Configuration",
                rpt_sec2: "2. Load Analysis & Interaction",
                rpt_sec3: "3. Shear Design Check",
                rpt_sec4: "4. Code Compliance Warnings",
                rpt_geo_mat: "Geometry & Materials",
                rpt_dim: "Dimensions", rpt_con: "Concrete (f'c)",
                rpt_cov: "Clear Cover", rpt_st: "Steel (fy)",
                rpt_len: "Length (Lu)", rpt_mod: "Mode",
                rpt_reinf_det: "Reinforcement Details",
                rpt_main: "Main Bar Size", rpt_area: "Area",
                rpt_conf: "Config", rpt_bars: "Bars",
                rpt_tie: "Tie Bar", rpt_tie_sp: "Tie Spacing",
                rpt_legs: "Shear Legs",
                rpt_param: "Parameter", rpt_app: "Applied Load (Active)", rpt_lim: "Capacity Limit (Max)", rpt_chk: "Check",
                rpt_ax: "Axial Force (Pu)", rpt_mx: "Moment Y (Muy)", rpt_my: "Moment Z (Muz)",
                rpt_dc: "D/C Ratio",
                rpt_stat: "Interaction Status",
                rpt_dir: "Direction", rpt_dem: "Shear Demand (Vu)", rpt_prov: "Provided Legs", rpt_cap_chk: "Capacity Check",
                rpt_xdir: "Y-Direction", rpt_ydir: "Z-Direction",
                rpt_legs_w: "legs (along Width)", rpt_legs_d: "legs (along Depth)",
                rpt_no_warn: "No warnings generated.",
                rpt_footer: "Generated by RC Column 3D Interaction Tool",
                btn_gen_rpt: "Generate Summary Report",
                w_small_ecc: "⚠️ Small Eccentricity", w_small_ecc_d: "Moments < M_min. Verify accidental torsion.",
                w_low_rho: "⚠️ Low Rebar Ratio", w_min_1: "(Min 1%)",
                w_high_rho: "⚠️ High Rebar Ratio", w_max_8: "(Max 8%)",
                w_high_seis: "⚠️ High Seismic Rho", w_max_4: "(Practical Max 4%)",
                w_reinf_ok: "✓ Rebar Ratio",
                w_insuff_ash: "⚠️ Insufficient Ash", w_need_legs: "Need more legs or larger ties.",
                w_bad_tie: "⚠️ Invalid Tie Spacing", w_max_for: "Max for",
                w_tie_ok: "✓ Tie Spacing", w_ok: "OK",
                w_slender: "⚠️ Slender", w_mmag: "Moment Magnification applied.",
                w_vert_gap: "⚠️ Tight Vertical Spacing", w_agg: "might block aggregate flow.",
                w_x_cong: "⚠️ X-Legs Congested", w_y_cong: "⚠️ Y-Legs Congested", w_vib: "Hard to vibrate.",
                w_aspect: "⚠️ High Aspect Ratio", w_wall: "Ratio > 3 classifies as a <b>Wall</b> (ACI 318).",
                opt_run: "Optimizing...", opt_done: "Done! Optimized.", opt_fail: "No better solution found."
            },
            zh: {
                lbl_shape: "斷面形狀",
                opt_rect: "矩形",
                opt_circ: "圓形",
                lbl_n_total: "總支數 (n)",
                btn_login: "登入",
                btn_logout: "登出",
                modal_title: "存取入口",
                modal_desc: "登入以同步您的資料。",
                btn_login_submit: "登入",
                btn_register: "註冊",
                btn_guest: "訪客登入",
                btn_wireframe: "線框模式",
                lbl_sec_view: "斷面視圖",
                btn_save: "儲存至雲端",
                btn_saving: "儲存中...",
                btn_saved: "已儲存!",
                val_mode_regular: "規則排列",
                val_mode_custom: "自訂配置",
                val_ok: "符合",
                w_reinf_ratio: "✓ 鋼筋比", 
                w_tie_spacing: "✓ 箍筋間距", 
                rule_gravity: "非耐震 (16db, 柱寬)",
                rule_seismic: "耐震 (d/4, 6db, 15cm)",
                app_title: "RC 鋼筋混凝土柱 3D 交互作用",
                app_desc: "雙向彎矩強度分析 (建築物混凝土結構設計規範 112)",
                status_ready: "就緒",
                opt_title: "自動優化",
                opt_lock: "鎖定屬性 (保持不變):",
                lbl_lock_dim: "尺寸", lbl_lock_mat: "材料", lbl_lock_bar: "鋼筋",
                btn_opt: "自動設計斷面",
                sec_geo: "1. 斷面幾何",
                lbl_width: "寬度 b (cm)", lbl_depth: "深度 h (cm)",
                lbl_cover: "保護層 (cm)", lbl_lu: "無支撐長度 Lu (m)",
                sec_mat: "2. 材料性質",
                lbl_fc: "混凝土 f'c (kgf/cm²)", lbl_fy: "鋼筋 fy (kgf/cm²)",
                sec_rebar: "3. 鋼筋配置",
                lbl_reg: "規則排列", lbl_cust: "自訂座標",
                lbl_size: "鋼筋號數 (Ab)",
                lbl_nz: "頂/底支數 (ny)", lbl_nx: "側面支數 (nz)",
                lbl_cust_layout: "自訂配置 (y, z, db)",
                btn_gen: "從規則配置生成",
                sum_paste: "貼上座標",
                ph_paste_rebar: "複製欄位:\nz  y  db(cm)",
                btn_load_rebar: "載入鋼筋",
                th_x: "y (cm)", th_y: "z (cm)", th_db: "db (cm)",
                btn_add_bar: "新增鋼筋",
                sec_loads: "4. 極限載重 (Factored)",
                lbl_vux: "全域 Vuy (tf)", lbl_vuy: "全域 Vuz (tf)",
                sum_paste_load: "批次貼上 (Excel)",
                ph_paste_load: "從 Excel 複製:\nPu  Muy  Muz",
                btn_load_data: "載入數據",
                th_pu: "Pu (tf)", th_mux: "Muy (tf-m)", th_muy: "Muz (tf-m)",
                btn_add_case: "新增載重",
                sec_shear: "5. 剪力設計 (Vu)",
                lbl_seismic: "耐震設計 (特殊抗彎構架)",
                lbl_hoop: "閉合箍筋 (一般)",
                lbl_spiral: "螺旋箍筋",
                lbl_app_opt: "附錄選項",
                opt_app_none: "無 (僅摘要)",
                opt_app_sum: "摘要 (3D + 前5組斷面)",
                opt_app_full: "完整 (3D + 所有斷面)",
                rpt_app_title: "附錄: 交互作用圖",
                rpt_3d_view: "3D 交互作用曲面",
                rpt_slice_view: "2D 交互作用切面 (Cut)",
                rpt_case: "載重案例",
                rpt_angle: "載重角度",
                lbl_tie_db: "箍筋直徑 db (cm)", lbl_tie_s: "箍筋間距 s (cm)",
                lbl_leg_x: "Y向 肢數 (Legs)", lbl_leg_y: "Z向 肢數 (Legs)",
                lbl_legs_circ: "剪力肢數 (總數)",
                rpt_res: "合力 (Resultant)",
                leg_nom: "標稱強度 (Pn)", leg_des: "設計強度 (ϕPn)",
                tit_check: "安全檢核 (D/C Ratio)",
                lbl_coord: "座標點:",
                tit_max: "最大設計強度",
                lbl_ratio: "容量比 (D/C)",
                sts_safe: "安全 (SAFE)", sts_fail: "破壞 (FAILURE)", sts_shear: "剪力破壞",
                rpt_title: "RC 柱結構分析報告",
                rpt_sub: "雙向交互作用與剪力設計 (台灣規範 112)",
                rpt_sec1: "1. 斷面配置",
                rpt_sec2: "2. 載重分析與交互作用",
                rpt_sec3: "3. 剪力設計檢核",
                rpt_sec4: "4. 規範符合性警告",
                rpt_geo_mat: "幾何與材料",
                rpt_dim: "尺寸", rpt_con: "混凝土 (f'c)",
                rpt_cov: "保護層", rpt_st: "鋼筋 (fy)",
                rpt_len: "長度 (Lu)", rpt_mod: "模式",
                rpt_reinf_det: "配筋詳圖",
                rpt_main: "主筋尺寸", rpt_area: "面積",
                rpt_conf: "排列", rpt_bars: "根",
                rpt_tie: "箍筋", rpt_tie_sp: "箍筋間距",
                rpt_legs: "剪力肢數",
                rpt_param: "參數", rpt_app: "作用載重 (Active)", rpt_lim: "強度極限 (Max)", rpt_chk: "檢核",
                rpt_ax: "軸力 (Pu)", rpt_mx: "彎矩 Y (Muy)", rpt_my: "彎矩 Z (Muz)",
                rpt_dc: "D/C Ratio",
                rpt_stat: "交互作用狀態",
                rpt_dir: "方向", rpt_dem: "剪力需求 (Vu)", rpt_prov: "提供肢數", rpt_cap_chk: "容量檢核",
                rpt_xdir: "Y-方向", rpt_ydir: "Z-方向",
                rpt_legs_w: "支 (沿寬度)", rpt_legs_d: "支 (沿深度)",
                rpt_no_warn: "未產生警告訊息。",
                rpt_footer: "由 RC Column 3D 工具生成",
                btn_gen_rpt: "生成摘要報告",
                w_small_ecc: "⚠️ 偏心距過小", w_small_ecc_d: "彎矩 < M_min。請確認意外扭矩。",
                w_low_rho: "⚠️ 鋼筋比過低", w_min_1: "(最小 1%)",
                w_high_rho: "⚠️ 鋼筋比過高", w_max_8: "(最大 8%)",
                w_high_seis: "⚠️ 耐震鋼筋比高", w_max_4: "(建議最大 4%)",
                w_reinf_ok: "✓ 鋼筋比",
                w_insuff_ash: "⚠️ Ash 圍束不足", w_need_legs: "需增加肢數或加大箍筋。",
                w_bad_tie: "⚠️ 箍筋間距無效", w_max_for: "最大值",
                w_tie_ok: "✓ 箍筋間距", w_ok: "OK",
                w_slender: "⚠️ 細長柱", w_mmag: "已應用彎矩放大。",
                w_vert_gap: "⚠️ 垂直間距過密", w_agg: "可能阻礙骨材流動。",
                w_x_cong: "⚠️ Z向肢距過密", w_y_cong: "⚠️ X向肢距過密", w_vib: "難以震動搗實。",
                w_aspect: "⚠️ 長寬比過大", w_wall: "比例 > 3 歸類為<b>牆</b> (ACI 318)。",
                opt_run: "優化中...", opt_done: "完成！已優化。", opt_fail: "未找到更好的解。"
            }
        };
        function t(key) {
            return translations[currentLang][key] || key;
        }
        function t(key) { return translations[currentLang][key] || key; }
        function toggleLanguage() {
            currentLang = currentLang === 'en' ? 'zh' : 'en';
            document.getElementById('lang-label').innerText = currentLang === 'en' ? '中文' : 'EN';
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const icon = el.querySelector('i');
                if (translations[currentLang][key]) {
                    el.innerHTML = t(key);
                }
            });
            const pasteRebar = document.getElementById('paste_rebar');
            if(pasteRebar) pasteRebar.placeholder = t('ph_paste_rebar');
            const pasteLoads = document.getElementById('paste_loads');
            if(pasteLoads) pasteLoads.placeholder = t('ph_paste_load');
            updateApp(); 
            if (!document.getElementById('history-modal').classList.contains('hidden')) loadHistory();
        }
        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            const html = document.documentElement;
            const icon = document.getElementById('dark-icon');
            const overlayBtns = document.querySelectorAll('.absolute.top-4.left-4 button');
            if (isDarkMode) {
                html.classList.add('dark');
                icon.classList.remove('fa-moon');
                icon.classList.add('fa-sun');
                overlayBtns.forEach(btn => {
                    btn.className = "bg-slate-700/80 hover:bg-slate-600 text-white backdrop-blur-sm border border-slate-500/50 px-3 py-1.5 rounded text-xs font-bold transition";
                });
            } else {
                html.classList.remove('dark');
                icon.classList.remove('fa-sun');
                icon.classList.add('fa-moon');
                overlayBtns.forEach(btn => {
                    btn.className = "bg-gray-100/80 hover:bg-gray-200/80 text-gray-900 backdrop-blur-sm border border-gray-300/50 px-3 py-1.5 rounded text-xs font-bold transition";
                });
            }
            if (scene) {
                scene.background = new THREE.Color(isDarkMode ? 0x111827 : 0xffffff);
                const grid = scene.children.find(c => c.type === 'GridHelper');
                if(grid) {
                    scene.remove(grid);
                    const c1 = isDarkMode ? 0x475569 : 0x94a3b8;
                    const c2 = isDarkMode ? 0x1e293b : 0xe2e8f0;
                    const newGrid = new THREE.GridHelper(2000, 50, c1, c2);
                    newGrid.position.y = 0;
                    scene.add(newGrid);
                }
            }
            updateApp();
        }
        function toggleSidebar() {
            const sb = document.getElementById('sidebar');
            if (sb.classList.contains('-translate-x-full')) {
                sb.classList.remove('-translate-x-full', 'w-0', 'p-0', 'overflow-hidden');
                sb.classList.add('translate-x-0', 'w-96');
            } else {
                sb.classList.add('-translate-x-full', 'w-0', 'p-0', 'overflow-hidden');
                sb.classList.remove('translate-x-0', 'w-96');
            }
            setTimeout(onWindowResize, 350); 
        }
        function importRegularToCustom() {
            const shape = document.getElementById('col_shape').value;
            const b = parseFloat(document.getElementById('col_b').value);
            const h = parseFloat(document.getElementById('col_h').value);
            const cover = parseFloat(document.getElementById('col_cover').value) || 4.0;
            const Ab_bar = parseFloat(document.getElementById('bar_size').value);
            const db = Math.sqrt(Ab_bar * 4 / Math.PI);
            const db_tie = parseFloat(document.getElementById('shear_db').value) || 1.3;
            const d_center = cover + db_tie + (db / 2); 
            const tbody = document.querySelector('#table-rebar tbody');
            tbody.innerHTML = ''; 
            const newRows = [];
            if (shape === 'circ') {
                const n_circ = parseInt(document.getElementById('n_circ_bars').value);
                const radius = (b / 2) - d_center;
                for(let i=0; i<n_circ; i++) {
                    const theta = (Math.PI / 2) - (i * 2 * Math.PI / n_circ);
                    const x = radius * Math.cos(theta);
                    const y = radius * Math.sin(theta);
                    newRows.push({x: x, y: y, db: db});
                }
            } else {
                const nz = parseInt(document.getElementById('nz_bars').value);
                const nx = parseInt(document.getElementById('nx_bars').value);
                for(let i=0; i<nz; i++) {
                    const x = -b/2 + d_center + i * (b - 2*d_center) / (nz - 1);
                    newRows.push({x: x, y: h/2 - d_center, db: db});
                    newRows.push({x: x, y: -h/2 + d_center, db: db});
                }
                if (nx > 2) {
                    for(let j=1; j<nx-1; j++) {
                        const y = h/2 - d_center - j * (h - 2*d_center) / (nx - 1);
                        newRows.push({x: -b/2 + d_center, y: y, db: db});
                        newRows.push({x: b/2 - d_center, y: y, db: db});
                    }
                }
            }
            const clean = (val) => parseFloat(Number(val).toFixed(2));
            let html = '';
            newRows.forEach(bar => {
                html += `<tr>
                    <td><input type="number" step="0.1" value="${clean(bar.x)}" oninput="updateApp()"></td>
                    <td><input type="number" step="0.1" value="${clean(bar.y)}" oninput="updateApp()"></td>
                    <td><input type="number" step="0.01" value="${clean(bar.db)}" oninput="updateApp()"></td>
                    <td class="text-center"><i class="fa-solid fa-xmark btn-icon" onclick="removeRow(this)"></i></td>
                </tr>`;
            });
            tbody.innerHTML = html;
            updateApp();
        }
        function parseLoads() {
            const raw = document.getElementById('paste_loads').value;
            if(!raw) return;
            const rows = raw.trim().split(/\r?\n/);
            const tbody = document.querySelector('#table-loads tbody');
            tbody.innerHTML = ''; 
            rows.forEach(r => {
                const cols = r.trim().split(/\t|\s+/); 
                if(cols.length >= 3) {
                    addLoadRow(parseFloat(cols[0]), parseFloat(cols[1]), parseFloat(cols[2]));
                }
            });
            document.getElementById('paste_loads').value = '';
            updateApp();
        }
        function parseCustomRebar() {
            const raw = document.getElementById('paste_rebar').value;
            if(!raw) return;
            const rows = raw.trim().split(/\r?\n/);
            const tbody = document.querySelector('#table-rebar tbody');
            tbody.innerHTML = '';
            rows.forEach(r => {
                const cols = r.trim().split(/\t|\s+/);
                if(cols.length >= 3) {
                    addRebarRow(parseFloat(cols[0]), parseFloat(cols[1]), parseFloat(cols[2]));
                }
            });
            document.getElementById('paste_rebar').value = '';
            updateApp();
        }
        function toggleRebarMode() {
            const mode = document.querySelector('input[name="rebar_mode"]:checked').value;
            if(mode === 'regular') {
                document.getElementById('rebar-regular').classList.remove('hidden');
                document.getElementById('rebar-custom').classList.add('hidden');
            } else {
                document.getElementById('rebar-regular').classList.add('hidden');
                document.getElementById('rebar-custom').classList.remove('hidden');
            }
            updateApp();
        }
        function addRebarRow(x=25, y=25, db=2.54) {
            const tbody = document.querySelector('#table-rebar tbody');
            const row = document.createElement('tr');
            const clean = (val) => parseFloat(Number(val).toFixed(2));
            row.innerHTML = `
                <td><input type="number" step="0.1" value="${clean(x)}" oninput="updateApp()"></td>
                <td><input type="number" step="0.1" value="${clean(y)}" oninput="updateApp()"></td>
                <td><input type="number" step="0.01" value="${clean(db)}" oninput="updateApp()"></td>
                <td class="text-center"><i class="fa-solid fa-xmark btn-icon" onclick="removeRow(this)"></i></td>
            `;
            tbody.appendChild(row);
            updateApp();
        }
        function addLoadRow(Pu=200, Muz=30, Mux=15) {
            const tbody = document.querySelector('#table-loads tbody');
            const row = document.createElement('tr');
            const clean = (val) => parseFloat(Number(val).toFixed(2));
            row.innerHTML = `
                <td><input type="number" step="1" value="${clean(Pu)}" class="text-red-700 font-bold" oninput="updateApp()"></td>
                <td><input type="number" step="1" value="${clean(Muz)}" class="text-red-700 font-bold" oninput="updateApp()"></td>
                <td><input type="number" step="1" value="${clean(Mux)}" class="text-red-700 font-bold" oninput="updateApp()"></td>
                <td class="text-center"><i class="fa-solid fa-xmark btn-icon" onclick="removeRow(this)"></i></td>
            `;
            tbody.appendChild(row);
            updateApp(); 
        }
        function removeRow(btn) {
            btn.closest('tr').remove();
            updateApp();
        }
        function initTables() {
            addRebarRow(25, 25, 2.54);
            addRebarRow(-25, 25, 2.54);
            addRebarRow(25, -25, 2.54);
            addRebarRow(-25, -25, 2.54);
            addLoadRow(200, 30, 15, 0);
        }
        function makeUIResizable(elementId) {
            const el = document.getElementById(elementId);
            if (!el) return;
            el.style.transformOrigin = "0 0";
            if (el.querySelector('.resize-handle')) return;
            const handle = document.createElement('div');
            handle.className = 'resize-handle absolute bottom-0 right-0 w-6 h-6 cursor-nwse-resize z-50 flex items-center justify-center bg-gray-200/50 hover:bg-eng-accent/80 rounded-tl-lg transition-colors';
            handle.innerHTML = '<i class="fa-solid fa-expand text-[8px] text-gray-600"></i>';
            el.appendChild(handle);
            const getScale = () => {
                const match = el.style.transform.match(/scale\(([^)]+)\)/);
                return match ? parseFloat(match[1]) : 1;
            };
            handle.addEventListener('mousedown', function(e) {
                e.preventDefault();
                e.stopPropagation(); 
                const startX = e.clientX;
                const startScale = getScale();
                const startWidth = el.offsetWidth;
                const onMove = (em) => {
                    em.preventDefault();
                    em.stopPropagation();
                    const dx = em.clientX - startX;
                    const newScale = Math.max(0.5, (startWidth * startScale + dx) / startWidth);
                    el.style.transform = `scale(${newScale})`;
                };
                const onUp = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                };
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }
        function makeUIDraggable(elementId) {
            const el = document.getElementById(elementId);
            if (!el) return;
            el.style.cursor = 'move';
            el.addEventListener('mousedown', function(e) {
                if (['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA'].includes(e.target.tagName) || e.target.closest('.resize-handle')) {
                    return;
                }
                e.preventDefault();
                const computed = window.getComputedStyle(el);
                if (computed.right !== 'auto' || computed.bottom !== 'auto') {
                    const currentLeft = el.offsetLeft;
                    const currentTop = el.offsetTop;
                    el.style.right = 'auto';
                    el.style.bottom = 'auto';
                    el.style.left = currentLeft + 'px';
                    el.style.top = currentTop + 'px';
                }
                const startX = e.clientX;
                const startY = e.clientY;
                const startLeft = parseFloat(el.style.left) || 0;
                const startTop = parseFloat(el.style.top) || 0;
                el.style.zIndex = 1000;
                const onMove = (em) => {
                    em.preventDefault();
                    const dx = em.clientX - startX;
                    const dy = em.clientY - startY;
                    el.style.left = (startLeft + dx) + 'px';
                    el.style.top = (startTop + dy) + 'px';
                };
                const onUp = () => {
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                    el.style.zIndex = '';
                };
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
        }
        function init() {
            const container = document.getElementById('container-3d');
            const w = container.clientWidth;
            const h = container.clientHeight;
            scene = new THREE.Scene();
            scene.background = new THREE.Color(isDarkMode ? 0x111827 : 0xffffff);
            const gridHelper = new THREE.GridHelper(2000, 50, 0x94a3b8, 0xe2e8f0);
            gridHelper.position.y = 0; 
            scene.add(gridHelper);
            const origin = new THREE.Vector3(0, 0, 0);
            const len = 36;
            const headLen = 24;
            const headWidth = 12;
            const arrowX = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), origin, 350, 0xdc2626, headLen, headWidth);
            scene.add(arrowX);
            const arrowY = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), origin, 700, 0x15803d, headLen, headWidth);
            scene.add(arrowY);
            const arrowZ = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), origin, 350, 0x1d4ed8, headLen, headWidth);
            scene.add(arrowZ);
            scene.add(loadPointsGroup);
            scene.add(limitGroup);
            addLabel("Mny", 290, 16, 0, "#dc2626"); 
            addLabel("Pn", 16, 670, 0, "#15803d");  
            addLabel("Mnz", 0, 16, 290, "#1d4ed8"); 
            camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 5000);
            camera.position.set(1000, 1300, 1000);
            camera.up.set(0, 1, 0); 
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, preserveDrawingBuffer: true });            renderer.setSize(w, h);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 200, 100);
            scene.add(dirLight);
            window.addEventListener('resize', onWindowResize, false);
            animate();
            initTables();
            updateApp();
            updateApp();
            makeUIResizable('ui-section');
            makeUIDraggable('ui-section');
            makeUIResizable('ui-legend');
            makeUIDraggable('ui-legend');
        }
        function onWindowResize() {
            const container = document.getElementById('container-3d');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        function addLabel(text, x, y, z, color) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 128; canvas.height = 64;
            ctx.fillStyle = color;
            ctx.font = "bold 40px Arial";
            ctx.textAlign = "center";
            ctx.fillText(text, 64, 45);
            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.position.set(x, y, z);
            sprite.scale.set(40, 20, 1);
            scene.add(sprite);
        }
        function calculateInteractionSurface() {
            const b = parseFloat(document.getElementById('col_b').value);
            const h = parseFloat(document.getElementById('col_h').value);
            const fc = parseFloat(document.getElementById('mat_fc').value);
            const fy = parseFloat(document.getElementById('mat_fy').value);
            const cover = parseFloat(document.getElementById('col_cover').value) || 4.0;
            const shape = document.getElementById('col_shape').value;
            const eps_cu = 0.003;       
            const Es = 2.04 * 1000000;
            const eps_y = fy / Es;
            const beta1 = fc > 280 ? Math.max(0.65, 0.85 - 0.05 * (fc - 280) / 70) : 0.85;
            let bars = [];
            const isCustom = document.querySelector('input[name="rebar_mode"]:checked').value === 'custom';
            const rebarWarnings = [];
            const Ab_bar = parseFloat(document.getElementById('bar_size').value);
            const db_main = Math.sqrt(Ab_bar * 4 / Math.PI); 
            const db_tie = parseFloat(document.getElementById('shear_db').value); 
            const d_center = cover + db_tie + (db_main / 2);
            if (isCustom) {
                const rows = document.querySelectorAll('#table-rebar tbody tr');
                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input');
                    const x = parseFloat(inputs[0].value);
                    const y = parseFloat(inputs[1].value);
                    const db = parseFloat(inputs[2].value);
                    if(!isNaN(x) && !isNaN(y) && !isNaN(db) && db > 0) {
                        const Ab = Math.PI * Math.pow(db/2, 2);
                        bars.push({ x, y, Ab, db });
                    }
                });
                if(bars.length === 0) bars.push({x:0, y:0, Ab:0, db:0});
            } else {
                if (shape === 'rect') {
                    const nz = parseInt(document.getElementById('nz_bars').value);
                    const nx = parseInt(document.getElementById('nx_bars').value);
                    for(let i=0; i<nz; i++) {
                        const x = -b/2 + d_center + i * (b - 2*d_center) / (nz - 1);
                        bars.push({ x: x, y: h/2 - d_center, Ab: Ab_bar, db: db_main }); 
                        bars.push({ x: x, y: -h/2 + d_center, Ab: Ab_bar, db: db_main }); 
                    }
                    if (nx > 2) {
                        for(let j=1; j<nx-1; j++) {
                            const y = h/2 - d_center - j * (h - 2*d_center) / (nx - 1);
                            bars.push({ x: -b/2 + d_center, y: y, Ab: Ab_bar, db: db_main }); 
                            bars.push({ x: b/2 - d_center, y: y, Ab: Ab_bar, db: db_main }); 
                        }
                    }
                } else {
                    const D = b; 
                    const n_circ = parseInt(document.getElementById('n_circ_bars').value);
                    const radius_bar = (D/2) - d_center;
                    if (n_circ >= 3) {
                        const dTheta = (2 * Math.PI) / n_circ;
                        let currentAngle = Math.PI / 2; 
                        for(let i=0; i<n_circ; i++) {
                            const x = radius_bar * Math.cos(currentAngle);
                            const y = radius_bar * Math.sin(currentAngle);
                            bars.push({ x: x, y: y, Ab: Ab_bar, db: db_main });
                            currentAngle -= dTheta; 
                        }
                    }
                }
            }
            let outsideCount = 0;
            bars.forEach(bar => {
                let isOut = false;
                const barOuterRadius = bar.db / 2;
                if (shape === 'rect') {
                    if (Math.abs(bar.x) + barOuterRadius > b/2 || Math.abs(bar.y) + barOuterRadius > h/2) {
                        isOut = true;
                    }
                } else {
                    const distFromCenter = Math.sqrt(bar.x*bar.x + bar.y*bar.y);
                    if (distFromCenter + barOuterRadius > b/2) {
                        isOut = true;
                    }
                }
                if (isOut) outsideCount++;
            });
            if (outsideCount > 0) {
                rebarWarnings.push(`⚠️ <b>SECTION ERROR:</b> ${outsideCount} rebar(s) extend OUTSIDE the concrete boundary! Increase dimensions or reduce cover.`);
            }
            const fibers = [];
            const nzFib = 40, nxFib = 40; 
            if (shape === 'rect') {
                const dA = (b * h) / (nzFib * nxFib);
                const dx = b / nzFib, dy = h / nxFib;
                for(let i=0; i<nzFib; i++) {
                    for(let j=0; j<nxFib; j++) {
                        fibers.push({
                            x: -b/2 + (i + 0.5) * dx,
                            y: -h/2 + (j + 0.5) * dy,
                            dA: dA
                        });
                    }
                }
            } else {
                const D = b; 
                const R = D/2;
                const dA = (D * D) / (nzFib * nxFib); 
                const dx = D / nzFib, dy = D / nxFib;
                for(let i=0; i<nzFib; i++) {
                    for(let j=0; j<nxFib; j++) {
                        const x = -R + (i + 0.5) * dx;
                        const y = -R + (j + 0.5) * dy;
                        if (x*x + y*y <= R*R) {
                            fibers.push({ x, y, dA });
                        }
                    }
                }
            }
            const Ag = shape === 'rect' ? b * h : (Math.PI * Math.pow(b/2, 2));
            let Ast = 0; bars.forEach(b => Ast += b.Ab);
            const Po_nominal = 0.85 * fc * (Ag - Ast) + fy * Ast;
            const isSpiral = shape === 'circ' && document.querySelector('input[name="circ_type"]:checked')?.value === 'spiral';
            const phi_compression_base = isSpiral ? 0.75 : 0.65;
            const curves = [];
            const numAngles = 72; 
            const c_ratios = [2.0, 1.2, 1.0];
            for(let r=0.9; r>=0.1; r-=0.05) c_ratios.push(r);
            c_ratios.push(0.001);
            const corners = [ {x: b/2, y: h/2}, {x: b/2, y: -h/2}, {x: -b/2, y: h/2}, {x: -b/2, y: -h/2} ];
            for (let i = 0; i < numAngles; i++) {
                const theta = (i / numAngles) * Math.PI * 2;
                const cosT = Math.cos(theta);
                const sinT = Math.sin(theta);
                const curvePoints = [];
                let d_max_concrete = -Infinity; 
                if (shape === 'circ') {
                    d_max_concrete = b / 2;
                } else {
                    corners.forEach(p => {
                        const d = p.x * cosT + p.y * sinT;
                        if(d > d_max_concrete) d_max_concrete = d;
                    });
                }
                c_ratios.forEach(ratio => {
                    const c = d_max_concrete * 2 * ratio; 
                    if (c <= 0.001) return; 
                    const dist_NA_ref = d_max_concrete - c; 
                    let Pn = 0, Mnz = 0, Mnx = 0, max_strain_t = 0;
                    const dist_limit_comp = d_max_concrete - beta1 * c;
                    fibers.forEach(fib => {
                        const proj = fib.x * cosT + fib.y * sinT;
                        if (proj > dist_limit_comp) {
                            const force = 0.85 * fc * fib.dA;
                            Pn += force;
                            Mnz += force * fib.y; 
                            Mnx += force * fib.x; 
                        }
                    });
                    bars.forEach(bar => {
                        const proj = bar.x * cosT + bar.y * sinT;
                        const dist_from_NA = proj - dist_NA_ref;
                        const strain = eps_cu * dist_from_NA / c;
                        if (-strain > max_strain_t) max_strain_t = -strain;
                        let fs = strain * Es;
                        if (fs > fy) fs = fy;
                        if (fs < -fy) fs = -fy;
                        const force = fs * bar.Ab;
                        Pn += force;
                        Mnz += force * bar.y;
                        Mnx += force * bar.x;
                    });
                    if (Pn > -Ast * fy * 1.5) {
                        let phi = phi_compression_base;
                        if (max_strain_t <= eps_y) {
                            phi = phi_compression_base;
                        } else if (max_strain_t >= 0.005) {
                            phi = 0.90;
                        } else {
                            phi = phi_compression_base + (0.90 - phi_compression_base) * (max_strain_t - eps_y) / (0.005 - eps_y);
                        }
                        const Pn_tf = Pn / 1000;
                        const Mnz_tfm = Mnz / 100000;
                        const Mnx_tfm = Mnx / 100000;
                        curvePoints.push({
                            Pn: Pn_tf, Mnz: Mnz_tfm, Mnx: Mnx_tfm, phi: phi,
                            phiPn: phi * Pn_tf, phiMnz: phi * Mnz_tfm, phiMnx: phi * Mnx_tfm
                        });
                    }
                });
                const Pnt_kgf = -Ast * fy;
                const Pnt_tf = Pnt_kgf / 1000;
                curvePoints.push({ Pn: Pnt_tf, Mnz: 0, Mnx: 0, phi: 0.9, phiPn: 0.9*Pnt_tf, phiMnz: 0, phiMnx: 0 });
                curvePoints.sort((a,b) => b.Pn - a.Pn);
                curves.push(curvePoints);
            }
            return { curves, Po: Po_nominal / 1000, rebarWarnings, isSpiral };
        }
        let nominalMesh; 
        function updateApp() {
            const shape = document.getElementById('col_shape').value;
            const clamp = (id, min, max) => {
                const el = document.getElementById(id);
                let val = parseFloat(el.value);
                if (isNaN(val)) val = min;
                if (val < min) val = min;
                if (max !== undefined && val > max) val = max;
                return val;
            };
            const b_clamped = clamp('col_b', 20);
            const h_clamped = clamp('col_h', 20);
            const cover_clamped = clamp('col_cover', 4.0, 15.0);
            const lu_clamped = clamp('col_lu', 0.1);
            const fc_clamped = clamp('mat_fc', 140);
            const fy_clamped = clamp('mat_fy', 2800);
            let nz_clamped = clamp('nz_bars', 2);
            let nx_clamped = clamp('nx_bars', 2);
            const shear_db_clamped = clamp('shear_db', 1.0);
            const shear_s_clamped = clamp('shear_s', 3.0);
            let max_legs_x = nz_clamped;
            let max_legs_y = nx_clamped;
            let shear_circ_clamped = 2; 
            if (shape === 'circ') {
                 const n_total = parseFloat(document.getElementById('n_circ_bars').value) || 8;
                 const max_allowed = 2 + Math.ceil(n_total / 2);
                 shear_circ_clamped = clamp('shear_legs_circ', 2, max_allowed);
                 document.getElementById('shear_legs_circ').value = shear_circ_clamped;
            } else {
                 const shear_nz_clamped = clamp('shear_nz', 2, max_legs_x);
                 const shear_nx_clamped = clamp('shear_nx', 2, max_legs_y);
                 document.getElementById('shear_nz').value = shear_nz_clamped;
                 document.getElementById('shear_nx').value = shear_nx_clamped;
            }
            document.getElementById('col_cover').value = cover_clamped;
            const nzInput = document.getElementById('nz_bars');
            const nxInput = document.getElementById('nx_bars');
            const b_val = parseFloat(document.getElementById('col_b').value);
            const h_val = parseFloat(document.getElementById('col_h').value);
            const cv_val = parseFloat(document.getElementById('col_cover').value) || 4.0;
            const ab_val = parseFloat(document.getElementById('bar_size').value);
            const db_val = Math.sqrt(ab_val * 4 / Math.PI);
            const capInput = (inp, dim) => {
                const minS = Math.max(1.5 * db_val, 4.0);
                const tie = 1.27; 
                const available = dim - 2*cv_val - 2*tie;
                const maxN = Math.floor((available + minS) / (db_val + minS));
                if(parseInt(inp.value) > maxN) inp.value = Math.max(2, maxN);
            };
            const isCustom = document.querySelector('input[name="rebar_mode"]:checked').value === 'custom';
            if(!isCustom) {
                capInput(nzInput, b_val);
                capInput(nxInput, h_val);
            }
            drawSection2D();
            const data = calculateInteractionSurface();
            window.latestCalcData = data;
            const b = parseFloat(document.getElementById('col_b').value);
            const h = parseFloat(document.getElementById('col_h').value);
            const fc = parseFloat(document.getElementById('mat_fc').value);
            const fy = parseFloat(document.getElementById('mat_fy').value);
            const cover = parseFloat(document.getElementById('col_cover').value);
            let maxP_nominal = -Infinity, minP_nominal = Infinity;
            let maxMnz = 0, maxMnx = 0;
            data.curves.forEach(curve => {
                if(curve.length > 0) {
                    if (curve[0].Pn > maxP_nominal) maxP_nominal = curve[0].Pn;
                    if (curve[curve.length-1].Pn < minP_nominal) minP_nominal = curve[curve.length-1].Pn;
                    curve.forEach(pt => {
                        if(Math.abs(pt.Mnz) > maxMnz) maxMnz = Math.abs(pt.Mnz);
                        if(Math.abs(pt.Mnx) > maxMnx) maxMnx = Math.abs(pt.Mnx);
                    });
                }
            });
            const maxM_global = Math.max(maxMnz, maxMnx);
            const TARGET_HEIGHT = 800; 
            const TARGET_RADIUS = 320;
            vizScales.p = maxP_nominal !== minP_nominal ? TARGET_HEIGHT / (maxP_nominal - minP_nominal) : 1;
            vizScales.m = maxM_global > 0 ? TARGET_RADIUS / maxM_global : 1;
            const phi_compression = data.isSpiral ? 0.75 : 0.65;
            const P_limit_design = 0.80 * phi_compression * data.Po; 
            function createMesh(isDesignCurve, matColor, opacity, isWire) {
                const levels = 80; 
                const numAngles = data.curves.length; 
                const vertices = [];
                const indices = [];
                let curMaxP;
                if(isDesignCurve) curMaxP = P_limit_design;
                else curMaxP = maxP_nominal;
                const stepP = (curMaxP - minP_nominal) / levels;
                for(let i=0; i<=levels; i++) {
                    const P_target = curMaxP - i * stepP;
                    for(let j=0; j<numAngles; j++) {
                        const curve = data.curves[j];
                        let pt = { Mnz: 0, Mnx: 0 }; 
                        for(let k=0; k<curve.length-1; k++) {
                            const p1 = isDesignCurve ? curve[k].phiPn : curve[k].Pn;
                            const p2 = isDesignCurve ? curve[k+1].phiPn : curve[k+1].Pn;
                            if ((P_target <= p1 && P_target >= p2) || (P_target >= p1 && P_target <= p2)) {
                                if (Math.abs(p1 - p2) < 0.001) {
                                    pt = curve[k];
                                } else {
                                    const r = (P_target - p1) / (p2 - p1);
                                    const mnz1 = isDesignCurve ? curve[k].phiMnz : curve[k].Mnz;
                                    const mnz2 = isDesignCurve ? curve[k+1].phiMnz : curve[k+1].Mnz;
                                    const mnx1 = isDesignCurve ? curve[k].phiMnx : curve[k].Mnx;
                                    const mnx2 = isDesignCurve ? curve[k+1].phiMnx : curve[k+1].Mnx;
                                    pt = {
                                        Mnz: mnz1 + r * (mnz2 - mnz1),
                                        Mnx: mnx1 + r * (mnx2 - mnx1)
                                    };
                                }
                                break;
                            }
                        }
                        const x = pt.Mnz * vizScales.m;
                        const z = pt.Mnx * vizScales.m;
                        const y = (P_target - minP_nominal) * vizScales.p;
                        vertices.push(x, y, z);
                    }
                }
                for(let i=0; i<levels; i++) {
                    for(let j=0; j<numAngles; j++) {
                        const nextJ = (j + 1) % numAngles;
                        const row1 = i * numAngles;
                        const row2 = (i + 1) * numAngles;
                        indices.push(row1 + j, row2 + j, row1 + nextJ);
                        indices.push(row1 + nextJ, row2 + j, row2 + nextJ);
                    }
                }
                if (isDesignCurve) {
                    const topY = (curMaxP - minP_nominal) * vizScales.p;
                    const centerIndex = vertices.length / 3;
                    vertices.push(0, topY, 0); 
                    for(let j=0; j<numAngles; j++) {
                        indices.push(centerIndex, j, (j + 1) % numAngles);
                    }
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                const mat = new THREE.MeshPhongMaterial({
                    color: matColor,
                    transparent: true, opacity: opacity,
                    side: THREE.DoubleSide, shininess: 100, specular: 0x222222,
                    wireframe: isWireframe || isWire, depthWrite: !isWire && opacity > 0.5 
                });
                const mesh = new THREE.Mesh(geometry, mat);
                mesh.position.y = -(0 - minP_nominal) * vizScales.p;
                return mesh;
            }
            if(nominalMesh) scene.remove(nominalMesh);
            const meshCol = isDarkMode ? 0xcbd5e1 : 0x94a3b8; 
            const wireCol = isDarkMode ? 0x94a3b8 : 0x64748b;
            nominalMesh = createMesh(false, meshCol, 0.15, false); 
            const wireGeo = new THREE.WireframeGeometry(nominalMesh.geometry);
            const wireMat = new THREE.LineBasicMaterial({ color: wireCol, transparent: true, opacity: 0.1 });
            const wireObj = new THREE.LineSegments(wireGeo, wireMat);
            nominalMesh.add(wireObj);
            scene.add(nominalMesh);
            if(pmnMesh) scene.remove(pmnMesh);
            pmnMesh = createMesh(true, 0x06b6d4, 0.6, false);
            scene.add(pmnMesh);
            loadPointsGroup.clear();
            const ptGeo = new THREE.SphereGeometry(9, 24, 24); 
            const loadRows = document.querySelectorAll('#table-loads tbody tr');
            const Vux_global = parseFloat(document.getElementById('global_vux').value) || 0;
            const Vuy_global = parseFloat(document.getElementById('global_vuy').value) || 0;
            const s_tie = parseFloat(document.getElementById('shear_s').value);
            const db_tie = parseFloat(document.getElementById('shear_db').value);
            const Av = Math.PI * Math.pow(db_tie/2, 2);
            const nz_legs = parseFloat(document.getElementById('shear_nz').value);
            const nx_legs = parseFloat(document.getElementById('shear_nx').value);
            const circ_legs = parseFloat(document.getElementById('shear_legs_circ').value); 
            const isSeismic = document.getElementById('seismic_mode').checked;
            let maxDemand = 0;
            let criticalCase = { Pu: 0, Muz: 0, Mux: 0, Vu: 0 };
            let shearFailure = false;
            loadRows.forEach(row => {
                const inputs = row.querySelectorAll('input');
                const Pu = parseFloat(inputs[0].value) || 0;
                let Muz = parseFloat(inputs[1].value) || 0;
                let Mux = parseFloat(inputs[2].value) || 0;
                const Vuz = inputs.length > 3 ? parseFloat(inputs[3].value) : Vux_global;
                const Vux = inputs.length > 4 ? parseFloat(inputs[4].value) : Vuy_global;
                const Lu_m = parseFloat(document.getElementById('col_lu').value) || 0;
                if(Lu_m > 0 && Pu > 0) {
                    const Lu_cm = Lu_m * 100;
                    const Ec = 15000 * Math.sqrt(fc);
                    const k = 1.0; 
                    const rx = 0.3 * h;
                    if( (k*Lu_cm/rx) > 22 ) {
                        const Igx = b * Math.pow(h,3) / 12;
                        const Pcx = (Math.PI**2 * 0.4 * Ec * Igx) / (k*Lu_cm)**2;
                        if(Pu*1000 < 0.75*Pcx) Muz *= Math.max(1.0, 1.0 / (1.0 - (Pu*1000)/(0.75*Pcx)));
                    }
                    const ry = 0.3 * b;
                    if( (k*Lu_cm/ry) > 22 ) {
                        const Igy = h * Math.pow(b,3) / 12;
                        const Pcy = (Math.PI**2 * 0.4 * Ec * Igy) / (k*Lu_cm)**2;
                        if(Pu*1000 < 0.75*Pcy) Mux *= Math.max(1.0, 1.0 / (1.0 - (Pu*1000)/(0.75*Pcy)));
                    }
                }
                let capM_radial = 0;
                let loadM_radial = Math.sqrt(Muz*Muz + Mux*Mux);
                let loadAngle = Math.atan2(Mux, Muz); 
                if(loadAngle < 0) loadAngle += 2*Math.PI;
                const numAngles = data.curves.length;
                const stepAngle = (2*Math.PI) / numAngles;
                const idx = Math.round(loadAngle / stepAngle) % numAngles;
                const targetCurve = data.curves[idx];
                if (Pu > P_limit_design || Pu < minP_nominal) {
                    capM_radial = 0;
                } else {
                    for(let k=0; k<targetCurve.length-1; k++) {
                        const p1 = targetCurve[k].phiPn;
                        const p2 = targetCurve[k+1].phiPn;
                        if ((Pu <= p1 && Pu >= p2) || (Pu >= p1 && Pu <= p2)) {
                            const r = (Pu - p1)/(p2 - p1);
                            const m1 = Math.sqrt(targetCurve[k].phiMnz**2 + targetCurve[k].phiMnx**2);
                            const m2 = Math.sqrt(targetCurve[k+1].phiMnz**2 + targetCurve[k+1].phiMnx**2);
                            capM_radial = m1 + r*(m2 - m1);
                            break;
                        }
                    }
                }
                let demand = (Pu > P_limit_design || Pu < minP_nominal) ? 9.99 : (capM_radial > 0.1 ? loadM_radial / capM_radial : 0);
                const Ag = (shape === 'rect') ? (b * h) : (Math.PI * Math.pow(b/2, 2));
                const Pu_kg = Pu * 1000;
                const calcPhiVn = (bw, d_depth, legs) => {
                    let Vc_stress = 0.53 * Math.sqrt(fc) + (Pu_kg / (6 * Ag));
                    if (isSeismic && Pu_kg < (Ag * fc) / 20) Vc_stress = 0;
                    if (Vc_stress < 0) Vc_stress = 0;
                    const Vc = Vc_stress * bw * d_depth / 1000;
                    const Av_tie = Math.PI * Math.pow(db_tie/2, 2);
                    const Vs = (legs * Av_tie * fy * d_depth) / s_tie / 1000;
                    const Vs_max = 2.12 * Math.sqrt(fc) * bw * d_depth / 1000;
                    return 0.75 * (Vc + Math.min(Vs, Vs_max));
                };
                let DCR_shear = 0;
                if (shape === 'rect') {
                    const d_x = h - cover - db_tie - (Math.sqrt(parseFloat(document.getElementById('bar_size').value)*4/Math.PI)/2); 
                    const phiVnz = calcPhiVn(b, d_x, nx_legs); 
                    const d_y = b - cover - db_tie - (Math.sqrt(parseFloat(document.getElementById('bar_size').value)*4/Math.PI)/2);
                    const phiVnx = calcPhiVn(h, d_y, nz_legs);
                    const DCR_vux = Math.abs(Vuz) / phiVnz;
                    const DCR_vuy = Math.abs(Vux) / phiVnx;
                    DCR_shear = Math.max(DCR_vux, DCR_vuy);
                } else {
                    const D = b; 
                    const d_eff = 0.8 * D;
                    const Vu_resultant = Math.sqrt(Vuz**2 + Vux**2);
                    const phiVn_circ = calcPhiVn(D, d_eff, circ_legs);
                    DCR_shear = Vu_resultant / phiVn_circ;
                }
                if (DCR_shear > 1.0) {
                    demand = Math.max(demand, 9.99);
                    shearFailure = true;
                } else {
                    demand = Math.max(demand, DCR_shear);
                }
                if (demand > maxDemand) {
                    maxDemand = demand;
                    criticalCase = { Pu, Muz, Mux, Vu: Math.max(Math.abs(Vuz), Math.abs(Vux)) };
                }
                const isPointSafe = demand <= 1.0;
                const ptMat = new THREE.MeshStandardMaterial({ 
                    color: isPointSafe ? 0xbf9000 : 0xff0000, 
                    emissive: isPointSafe ? 0xbf9000 : 0xff0000, 
                    emissiveIntensity: 0.6 
                });
                const ptMesh = new THREE.Mesh(ptGeo, ptMat);
                ptMesh.position.set(Muz * vizScales.m, Pu * vizScales.p, Mux * vizScales.m);
                loadPointsGroup.add(ptMesh);
            });
            let globalMaxPhiMnz = 0, globalMaxPhiMnx = 0;
            data.curves.forEach(c => {
                c.forEach(pt => {
                    if (Math.abs(pt.phiMnz) > globalMaxPhiMnz) globalMaxPhiMnz = Math.abs(pt.phiMnz);
                    if (Math.abs(pt.phiMnx) > globalMaxPhiMnx) globalMaxPhiMnx = Math.abs(pt.phiMnx);
                });
            });
            document.getElementById('max_phi_pn').innerText = P_limit_design.toFixed(1);
            document.getElementById('max_phi_mnz').innerText = globalMaxPhiMnz.toFixed(1);
            document.getElementById('max_phi_mnx').innerText = globalMaxPhiMnx.toFixed(1);
            document.getElementById('disp_pu').innerText = criticalCase.Pu.toFixed(1);
            document.getElementById('disp_mux').innerText = criticalCase.Muz.toFixed(1);
            document.getElementById('disp_muy').innerText = criticalCase.Mux.toFixed(1);
            document.getElementById('dc-val').innerText = maxDemand.toFixed(2);
            const isSafe = maxDemand <= 1.0;
            const bar = document.getElementById('dc-bar');
            bar.style.width = Math.min(maxDemand * 100, 100) + "%";
            bar.className = isSafe ? "h-4 rounded-full transition-all duration-500 bg-green-500" : "h-4 rounded-full transition-all duration-500 bg-red-500";
            const badge = document.getElementById('safety-msg');
            if (shearFailure) {
                badge.innerText = t('sts_shear'); 
                badge.className = "text-center text-xs font-bold mt-2 py-1 rounded bg-red-100 text-red-700";
            } else {
                badge.innerText = isSafe ? t('sts_safe') : t('sts_fail'); 
                badge.className = isSafe ? "text-center text-xs font-bold mt-2 py-1 rounded bg-green-100 text-green-700" : "text-center text-xs font-bold mt-2 py-1 rounded bg-red-100 text-red-700";
            }
            draw3DLimits(data, P_limit_design, globalMaxPhiMnz, globalMaxPhiMnx, criticalCase);
            checkSpacingAndWarnings(b, h, cover, isCustom, data.rebarWarnings);
        }
        function checkSpacingAndWarnings(b, h, cover, isCustom, customWarnings = []) {
            const warningsDiv = document.getElementById('code-warnings');
            warningsDiv.innerHTML = "";
            warningsDiv.classList.remove('hidden');
            const shape = document.getElementById('col_shape').value;
            if (shape === 'circ') {
                const isSpiral = document.querySelector('input[name="circ_type"]:checked')?.value === 'spiral';
                const n_circ = parseInt(document.getElementById('n_circ_bars').value);
                const db_main = Math.sqrt(parseFloat(document.getElementById('bar_size').value) * 4 / Math.PI);
                const db_tie = parseFloat(document.getElementById('shear_db').value);
                const core_dia = b - 2*cover - 2*db_tie - db_main;
                const perimeter = Math.PI * core_dia;
                const required_perim = n_circ * (db_main + 4.0); 
                if (perimeter < required_perim) {
                     warningsDiv.innerHTML += `<div class="text-amber-600 border-b pb-1 mb-1">⚠️ Circular Spacing Tight<br><span class="text-[9px]">Check aggregate flow</span></div>`;
                }
            }
            if (isCustom && customWarnings && customWarnings.length > 0) {
                 customWarnings.forEach(msg => {
                    warningsDiv.innerHTML += `<div class="text-amber-700 font-bold border-b pb-1 mb-1 border-amber-300 bg-amber-50 p-1 rounded">⚠️ ${msg}</div>`;
                 });
            }
            const ratio = Math.max(b, h) / Math.min(b, h);
            if (ratio > 3.0) {
                 warningsDiv.innerHTML += `<div class="text-amber-600 border-b pb-1 mb-1">${t('w_aspect')} (1:${ratio.toFixed(1)})<br><span class="text-[9px]">${t('w_wall')}</span></div>`;
            }
            const isSeismic = document.getElementById('seismic_mode').checked;
            const pu_val = parseFloat(document.getElementById('disp_pu').innerText) || 0;
            const mux_val = parseFloat(document.getElementById('disp_mux').innerText) || 0;
            const muy_val = parseFloat(document.getElementById('disp_muy').innerText) || 0;
            if (pu_val > 0) {
                const e_min_x = (1.5 + 0.03 * h) / 100; 
                const e_min_y = (1.5 + 0.03 * b) / 100;
                const M_min_x = pu_val * e_min_x;
                const M_min_y = pu_val * e_min_y;
                if (Math.abs(mux_val) < M_min_x && Math.abs(muy_val) < M_min_y && (Math.abs(mux_val)+Math.abs(muy_val)) > 0.001) {
                    warningsDiv.innerHTML += `<div class="text-amber-600 border-b pb-1 mb-1">${t('w_small_ecc')}<br><span class="text-[9px]">${t('w_small_ecc_d')}</span></div>`;
                }
            }
            let Ast_total = 0;
            if (isCustom) {
                const rows = document.querySelectorAll('#table-rebar tbody tr');
                rows.forEach(row => {
                   const inputs = row.querySelectorAll('input');
                   const db = parseFloat(inputs[2].value);
                   if(!isNaN(db)) Ast_total += Math.PI * Math.pow(db/2, 2);
                });
            } else {
                const ab_val = parseFloat(document.getElementById('bar_size').value);
                if (shape === 'circ') {
                    const n_circ = parseInt(document.getElementById('n_circ_bars').value) || 0;
                    Ast_total = n_circ * ab_val;
                } else {
                    const nz = parseInt(document.getElementById('nz_bars').value);
                    const nx = parseInt(document.getElementById('nx_bars').value);
                    const count = (2 * nz) + Math.max(0, 2 * (nx - 2));
                    Ast_total = count * ab_val;
                }
            }
            let Ag;
            if (shape === 'circ') {
                Ag = Math.PI * Math.pow(b / 2, 2);
            } else {
                Ag = b * h;
            }
            const rho = Ast_total / Ag;
            const rho_pct = (rho * 100).toFixed(2);
            if (rho < 0.01) {
                warningsDiv.innerHTML += `<div class="text-red-600 border-b pb-1 mb-1">${t('w_low_rho')}: <b>${rho_pct}%</b> <span class="text-[9px]">${t('w_min_1')}</span></div>`;
            } else if (rho > 0.08) {
                warningsDiv.innerHTML += `<div class="text-red-600 border-b pb-1 mb-1">${t('w_high_rho')}: <b>${rho_pct}%</b> <span class="text-[9px]">${t('w_max_8')}</span></div>`;
            } else if (rho > 0.04 && isSeismic) {
                 warningsDiv.innerHTML += `<div class="text-amber-600 border-b pb-1 mb-1">${t('w_high_seis')}: <b>${rho_pct}%</b> <span class="text-[9px]">${t('w_max_4')}</span></div>`;
            } else {
                 warningsDiv.innerHTML += `<div class="text-green-700 border-b pb-1 mb-1">${t('w_reinf_ratio')}: <b>${rho_pct}%</b></div>`;
            }
            const s_tie = parseFloat(document.getElementById('shear_s').value);
            const db_tie = parseFloat(document.getElementById('shear_db').value);
            const leastDim = Math.min(b, h);
            let maxS = 0;
            let rule = "";
            if (isSeismic) {
                const ab_val_main = parseFloat(document.getElementById('bar_size').value); 
                const maxDb = Math.sqrt(ab_val_main * 4 / Math.PI); 
                const limit1 = leastDim / 4;
                const limit2 = 6 * maxDb;
                maxS = Math.min(limit1, limit2, 15.0);
                rule = t('rule_seismic');
                const bc_x = b - 2*cover;
                const bc_y = h - 2*cover;
                const Ach = bc_x * bc_y;
                const Ag_col = b * h;
                const fyt = parseFloat(document.getElementById('mat_fy').value);
                const fc = parseFloat(document.getElementById('mat_fc').value);
                const Av_bar = Math.PI * Math.pow(db_tie/2, 2);
                if (shape === 'circ') {
                    const D = b;
                    const d_core = D - 2 * cover;
                    const Ach = Math.PI * Math.pow(d_core/2, 2);
                    const Ag_col = Math.PI * Math.pow(D/2, 2);
                    const isSpiral = document.querySelector('input[name="circ_type"]:checked')?.value === 'spiral';
                    if (isSpiral) {
                        const rho_s_prov = (4 * Av_bar) / (d_core * s_tie);
                        const req1 = 0.45 * ((Ag_col / Ach) - 1) * (fc / fyt);
                        const req2 = 0.12 * (fc / fyt);
                        const rho_s_req = Math.max(req1, req2);
                        if (rho_s_prov < rho_s_req) {
                             warningsDiv.innerHTML += `<div class="text-red-600 border-b pb-1 mb-1">⚠️ Low Spiral Ratio ρs<br><span class="text-[9px]">Prov: ${(rho_s_prov*100).toFixed(2)}% < Req: ${(rho_s_req*100).toFixed(2)}%</span></div>`;
                        } else {
                             warningsDiv.innerHTML += `<div class="text-green-700 border-b pb-1 mb-1">✓ Spiral ρs OK</div>`;
                        }
                    } else {
                        if(isSeismic && s_tie > 15) {
                             warningsDiv.innerHTML += `<div class="text-red-600 border-b pb-1 mb-1">⚠️ Hoop Spacing > 15cm</div>`;
                        }
                    }
                } else {
                    const bc_x = b - 2*cover;
                    const bc_y = h - 2*cover;
                    const Ach = bc_x * bc_y;
                    const Ag_col = b * h;
                    const Ash_prov_x = parseFloat(document.getElementById('shear_nx').value) * Av_bar; 
                    const Ash_prov_y = parseFloat(document.getElementById('shear_nz').value) * Av_bar;
                    const factor1 = 0.3 * (s_tie * bc_x * fc / fyt) * ((Ag_col / Ach) - 1);
                    const factor2 = 0.09 * (s_tie * bc_x * fc / fyt);
                    const Ash_req_x = Math.max(factor1, factor2);
                    const factor1_y = 0.3 * (s_tie * bc_y * fc / fyt) * ((Ag_col / Ach) - 1);
                    const factor2_y = 0.09 * (s_tie * bc_y * fc / fyt);
                    const Ash_req_y = Math.max(factor1_y, factor2_y);
                    if (Ash_prov_x < Ash_req_x || Ash_prov_y < Ash_req_y) {
                         warningsDiv.innerHTML += `<div class="text-red-600 border-b pb-1 mb-1">${t('w_insuff_ash')}<br><span class="text-[9px]">${t('w_need_legs')}</span></div>`;
                    }
                }
            } else {
                const ab_val_main = parseFloat(document.getElementById('bar_size').value);
                const maxDb = Math.sqrt(ab_val_main * 4 / Math.PI);
                const limit1 = 16 * maxDb;
                const limit2 = 48 * db_tie;
                maxS = Math.min(limit1, limit2, leastDim);
                rule = t('rule_gravity');
            }
            if (s_tie > maxS) {
                warningsDiv.innerHTML += `<div class="text-red-600 border-b pb-1 mb-1">${t('w_bad_tie')}: <b>${s_tie} cm</b><br><span class="text-[9px]">${t('w_max_for')} ${rule}: <b>${maxS.toFixed(1)} cm</b></span></div>`;
            } else {
                warningsDiv.innerHTML += `<div class="text-green-700 border-b pb-1 mb-1">${t('w_tie_spacing')}: ${s_tie} cm<br><span class="text-[9px] text-gray-400">(${rule} ${t('val_ok')})</span></div>`;
            }
            if (s_tie < 7.5) {
                 warningsDiv.innerHTML += `<div class="text-amber-600 border-b pb-1 mb-1">${t('w_vert_gap')}<br><span class="text-[9px]"><b>${s_tie} cm</b> ${t('w_agg')}</span></div>`;
            }
            const nLegsX = parseFloat(document.getElementById('shear_nz').value);
            const nLegsY = parseFloat(document.getElementById('shear_nx').value);
            const core_width = b - 2*cover; 
            const space_between_legs_x = nLegsX > 1 ? core_width / (nLegsX - 1) : core_width;
            const core_depth = h - 2*cover;
            const space_between_legs_y = nLegsY > 1 ? core_depth / (nLegsY - 1) : core_depth;
            const MIN_LEG_SPACE = 7.5; 
            if (nLegsX > 2 && space_between_legs_x < MIN_LEG_SPACE) {
                warningsDiv.innerHTML += `<div class="text-amber-600 border-b pb-1 mb-1">${t('w_x_cong')}<br><span class="text-[9px]">Gap: <b>${space_between_legs_x.toFixed(1)} cm</b>. ${t('w_vib')}</span></div>`;
            }
            if (nLegsY > 2 && space_between_legs_y < MIN_LEG_SPACE) {
                warningsDiv.innerHTML += `<div class="text-amber-600 border-b pb-1 mb-1">${t('w_y_cong')}<br><span class="text-[9px]">Gap: <b>${space_between_legs_y.toFixed(1)} cm</b>. ${t('w_vib')}</span></div>`;
            }
            const Lu = parseFloat(document.getElementById('col_lu').value) || 0;
            if (Lu > 0) {
                const r = 0.3 * h / 100; 
                const kLu_r = (1.0 * Lu) / r;
                if (kLu_r > 22) {
                     warningsDiv.innerHTML += `<div class="text-amber-600 font-bold border-b pb-1 mb-1">${t('w_slender')} (kL/r=${kLu_r.toFixed(0)})</div><div class="text-[9px] text-amber-700 leading-tight">${t('w_mmag')}</div>`;
                }
            }
            if (warningsDiv.innerHTML === "") warningsDiv.classList.add('hidden');
        }
        function capRebarInput(inputElem, width, cover, db) {
            const minS = Math.max(1.5 * db, 4.0);
            const tie = 1.27;
            const available = width - 2*cover - 2*tie;
            const maxN = Math.floor((available + minS) / (db + minS));
            if(parseInt(inputElem.value) > maxN) {
                inputElem.value = Math.max(2, maxN);
            }
        }
        function drawSection2D() {
            const canvas = document.getElementById('section-canvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;
            const shape = document.getElementById('col_shape').value;
            const col_b = parseFloat(document.getElementById('col_b').value);
            const col_depth = shape === 'circ' ? col_b : parseFloat(document.getElementById('col_h').value);
            const cover = parseFloat(document.getElementById('col_cover').value) || 4.0;
            const Ab_bar = parseFloat(document.getElementById('bar_size').value);
            const db_main = Math.sqrt(Ab_bar * 4 / Math.PI);
            const db_tie = parseFloat(document.getElementById('shear_db').value);
            ctx.clearRect(0, 0, w, h);
            const maxDim = Math.max(col_b, col_depth);
            const padding = 20; 
            const scale = (Math.min(w, h) - padding) / maxDim;
            const drawW = col_b * scale;
            const drawH = col_depth * scale;
            const ox = (w - drawW)/2;
            const oy = (h - drawH)/2;
            const bgCol = isDarkMode ? '#1e293b' : '#f0f9ff'; 
            const borderCol = isDarkMode ? '#94a3b8' : '#475569'; 
            ctx.fillStyle = bgCol; 
            ctx.strokeStyle = borderCol; 
            ctx.lineWidth = 2;
            if (shape === 'rect') {
                ctx.fillRect(ox, oy, drawW, drawH);
                ctx.strokeRect(ox, oy, drawW, drawH);
            } else {
                ctx.beginPath();
                ctx.arc(ox + drawW/2, oy + drawW/2, drawW/2, 0, 2*Math.PI);
                ctx.fill();
                ctx.stroke();
            }
            const tieColor = isDarkMode ? '#f87171' : '#b91c1c';
            const tieWidth = 1.5;
            const tLeft = ox + (cover * scale);
            const tTop = oy + (cover * scale);
            const tW = Math.max(0, drawW - 2*(cover * scale));
            const tH = Math.max(0, drawH - 2*(cover * scale));
            ctx.strokeStyle = tieColor;
            ctx.lineWidth = 1.5;
            ctx.lineJoin = 'round';
            ctx.beginPath();
            if (shape === 'rect') {
                ctx.rect(tLeft, tTop, tW, tH);
            } else {
                ctx.arc(ox + drawW/2, oy + drawH/2, tW/2, 0, 2*Math.PI);
            }
            ctx.stroke();
            const hookLen = 8;
            let hx, hy;
            const isSpiral = shape === 'circ' && document.querySelector('input[name="circ_type"]:checked')?.value === 'spiral';
            if (shape === 'rect') {
                hx = tLeft; 
                hy = tTop;
                ctx.beginPath();
                ctx.moveTo(hx + 2, hy + 2); ctx.lineTo(hx + hookLen, hy + hookLen);
                ctx.moveTo(hx + 2, hy + 2); ctx.lineTo(hx + 2, hy + hookLen + 2);
                ctx.stroke();
            } else if (!isSpiral) { 
                const cx = ox + drawW/2;
                const cy = oy + drawH/2;
                const r = tW / 2;
                const angDraw = 5 * Math.PI / 4;
                hx = cx + r * Math.cos(angDraw);
                hy = cy + r * Math.sin(angDraw);
                ctx.beginPath();
                ctx.moveTo(hx, hy); ctx.lineTo(hx + hookLen, hy + hookLen/2);
                ctx.moveTo(hx, hy); ctx.lineTo(hx + hookLen/2, hy + hookLen);
                ctx.stroke();
            } else {
                const cx = ox + drawW/2;
                const cy = oy + drawH/2;
                const r = tW / 2;
                const angDraw = 5 * Math.PI / 4;
                hx = cx + r * Math.cos(angDraw);
                hy = cy + r * Math.sin(angDraw);
                ctx.beginPath();
                ctx.moveTo(hx, hy); ctx.lineTo(hx + hookLen, hy + hookLen/2);
                ctx.moveTo(hx, hy); ctx.lineTo(hx + hookLen/2, hy + hookLen);
                ctx.stroke();
            }
            const isCustom = document.querySelector('input[name="rebar_mode"]:checked').value === 'custom';
            if (!isCustom) {
                ctx.beginPath();
                if (shape === 'rect') {
                    const nz_bars = parseInt(document.getElementById('nz_bars').value);
                    const nx_bars = parseInt(document.getElementById('nx_bars').value);
                    const nLegsX = Math.max(2, parseInt(document.getElementById('shear_nz').value));
                    const nLegsY = Math.max(2, parseInt(document.getElementById('shear_nx').value));
                    if (nLegsX > 2 && nz_bars > 2) {
                        for (let i = 1; i < nLegsX - 1; i++) {
                            const barIdx = Math.round(i * (nz_bars - 1) / (nLegsX - 1));
                            const xPos = tLeft + (barIdx * tW / (nz_bars - 1));
                            ctx.moveTo(xPos, tTop); ctx.lineTo(xPos, tTop + tH);
                            ctx.moveTo(xPos, tTop); ctx.lineTo(xPos + 3, tTop + 6);
                            ctx.moveTo(xPos, tTop + tH); ctx.lineTo(xPos - 3, tTop + tH - 6);
                        }
                    }
                    if (nLegsY > 2 && nx_bars > 2) {
                        for (let i = 1; i < nLegsY - 1; i++) {
                            const barIdx = Math.round(i * (nx_bars - 1) / (nLegsY - 1));
                            const yPos = tTop + (barIdx * tH / (nx_bars - 1));
                            ctx.moveTo(tLeft, yPos); ctx.lineTo(tLeft + tW, yPos);
                            ctx.moveTo(tLeft, yPos); ctx.lineTo(tLeft + 6, yPos + 3);
                            ctx.moveTo(tLeft + tW, yPos); ctx.lineTo(tLeft + tW - 6, yPos - 3);
                        }
                    }
                } else {
                    const n_circ = parseInt(document.getElementById('n_circ_bars').value);
                    const n_legs = parseInt(document.getElementById('shear_legs_circ').value) || 2;
                    const isSpiral = document.querySelector('input[name="circ_type"]:checked')?.value === 'spiral';
                    const d_cen_draw = cover + db_tie + (db_main / 2);
                    const r_draw = Math.max(0, ((col_b/2) - d_cen_draw) * scale);
                    const cx = ox + drawW/2;
                    const cy = oy + drawH/2;
                    const barPos = [];
                    for(let i=0; i<n_circ; i++) {
                        const theta = (2 * Math.PI * i) / n_circ - (Math.PI / 2);
                        barPos.push({ x: cx + r_draw * Math.cos(theta), y: cy - r_draw * Math.sin(theta) });
                    }
                    const num_ties = Math.max(0, n_legs - 2);
                    const offset = Math.floor(n_circ / 2);
                    for(let k=0; k<num_ties; k++) {
                        const idx = k % n_circ;
                        const p1 = barPos[idx];
                        const p2 = barPos[(idx + offset) % n_circ];
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        if (n_circ % 2 === 0) {
                            const dx = p2.x - p1.x;
                            const dy = p2.y - p1.y;
                            const ang = Math.atan2(dy, dx);
                            const hLen = 10; 
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p1.x + hLen * Math.cos(ang + Math.PI * 0.25), p1.y + hLen * Math.sin(ang + Math.PI * 0.25));
                            const ang2 = Math.atan2(-dy, -dx);
                            ctx.moveTo(p2.x, p2.y);
                            ctx.lineTo(p2.x + hLen * Math.cos(ang2 - Math.PI * 0.25), p2.y + hLen * Math.sin(ang2 - Math.PI * 0.25));
                        } else {
                            ctx.fillRect(p1.x - 1.5, p1.y - 1.5, 3, 3);
                            ctx.fillRect(p2.x - 1.5, p2.y - 1.5, 3, 3);
                        }
                    }
                }
                ctx.stroke();
            }
            ctx.fillStyle = '#dc2626'; 
            let barCoordinates = []; 
            function dot(rx, ry, area) {
                const px = ox + (col_b/2 + rx) * scale;
                const py = oy + (col_depth/2 - ry) * scale; 
                const rad = Math.sqrt(area/Math.PI) * scale; 
                ctx.beginPath();
                ctx.arc(px, py, Math.max(rad, 1.5), 0, 2*Math.PI);
                ctx.fill();
                barCoordinates.push({x: px, y: py});
            }
            if(isCustom) {
                const rows = document.querySelectorAll('#table-rebar tbody tr');
                rows.forEach(row => {
                    const inputs = row.querySelectorAll('input');
                    const x = parseFloat(inputs[0].value) || 0;
                    const y = parseFloat(inputs[1].value) || 0;
                    const db = parseFloat(inputs[2].value) || 0;
                    const area = Math.PI * Math.pow(db/2, 2);
                    if(area > 0) dot(x, y, area);
                });
            } else {
                const d_center = cover + db_tie + (db_main / 2);
                const shape = document.getElementById('col_shape').value;
                if (shape === 'rect') {
                    const nz = parseInt(document.getElementById('nz_bars').value);
                    const nx = parseInt(document.getElementById('nx_bars').value);
                    for(let i=0; i<nz; i++) {
                        const x = -col_b/2 + d_center + i * (col_b - 2*d_center) / (nz - 1);
                        dot(x, col_depth/2 - d_center, Ab_bar); 
                        dot(x, -col_depth/2 + d_center, Ab_bar); 
                    }
                    if (nx > 2) {
                        for(let j=1; j<nx-1; j++) {
                            const y = col_depth/2 - d_center - j * (col_depth - 2*d_center) / (nx - 1);
                            dot(-col_b/2 + d_center, y, Ab_bar); 
                            dot(col_b/2 - d_center, y, Ab_bar); 
                        }
                    }
                } else {
                    const n_circ = parseInt(document.getElementById('n_circ_bars').value);
                    const radius_bar = (col_b/2) - d_center;
                    for(let i=0; i<n_circ; i++) {
                        const theta = (2 * Math.PI * i) / n_circ - (Math.PI / 2);
                        const x = radius_bar * Math.cos(theta);
                        const y = radius_bar * Math.sin(theta);
                        dot(x, y, Ab_bar);
                    }
                }
            }
            ctx.font = "bold 10px Arial";
            ctx.fillStyle = "#64748b";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.beginPath();
            ctx.moveTo(ox + drawW/2, oy + drawH/2);
            ctx.lineTo(ox + drawW/2 + 25, oy + drawH/2);
            ctx.strokeStyle = "#dc2626"; 
            ctx.stroke();
            ctx.fillText("Y", ox + drawW/2 + 32, oy + drawH/2); 
            ctx.beginPath();
            ctx.moveTo(ox + drawW/2, oy + drawH/2);
            ctx.lineTo(ox + drawW/2, oy + drawH/2 - 25);
            ctx.strokeStyle = "#1d4ed8"; 
            ctx.stroke();
            ctx.fillText("Z", ox + drawW/2, oy + drawH/2 - 32); 
        }
        function toggleWireframe() {
            isWireframe = !isWireframe;
            if(pmnMesh) pmnMesh.material.wireframe = isWireframe;
        }
        init();
        scene.add(limitGroup);
        function draw3DLimits(data, maxPn, maxMnz, maxMnx) {
            limitGroup.clear();
            const minP = data.curves[0][data.curves[0].length-1].phiPn;
            const yTop = (maxPn - minP) * vizScales.p;
            const yBot = 0; 
            const planeGeo = new THREE.PlaneGeometry(maxMnz * 2.2 * vizScales.m, maxMnx * 2.2 * vizScales.m);
            const planeTop = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ color: 0x15803d, transparent: true, opacity: 0.15, side: THREE.DoubleSide }));
            planeTop.rotation.x = -Math.PI / 2;
            planeTop.position.set(0, yTop, 0);
            limitGroup.add(planeTop);
            addLabel3D(`ϕPn_max: ${maxPn.toFixed(1)}`, 0, yTop + 30, 0, "#15803d");
            const planeBot = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ color: 0xdc2626, transparent: true, opacity: 0.15, side: THREE.DoubleSide }));
            planeBot.rotation.x = -Math.PI / 2;
            planeBot.position.set(0, yBot, 0); 
            limitGroup.add(planeBot);
            addLabel3D(`ϕPn_min: ${minP.toFixed(1)}`, 0, yBot - 30, 0, "#dc2626");
            const midY = yTop * 0.45;
            const offset = 40; 
            const xDist = maxMnz * vizScales.m;
            addLabel3D(`+ϕMny: ${maxMnz.toFixed(1)}`, xDist + offset, midY, 0, "#dc2626");
            addLabel3D(`-ϕMny: ${maxMnz.toFixed(1)}`, -(xDist + offset), midY, 0, "#dc2626");
            const zDist = maxMnx * vizScales.m;
            addLabel3D(`+ϕMnz: ${maxMnx.toFixed(1)}`, 0, midY, zDist + offset, "#1d4ed8");
            addLabel3D(`-ϕMnz: ${maxMnx.toFixed(1)}`, 0, midY, -(zDist + offset), "#1d4ed8");
        }
        function addLabel3D(text, x, y, z, colorStr) {
        }
        async function runOptimization() {
            const btn = document.querySelector('button[onclick="runOptimization()"]');
            const status = document.getElementById('opt-status');
            btn.disabled = true;
            status.innerHTML = `<i class="fa-solid fa-spinner fa-spin"></i> ${t('opt_run')}`;
            const locks = Array.from(document.querySelectorAll('.opt-lock:checked')).map(cb => cb.value);
            const lockDim = locks.includes('dim');
            const lockBar = locks.includes('bar');
            let bestCost = Infinity;
            let bestConfig = {};
            const initB = parseFloat(document.getElementById('col_b').value);
            const initH = parseFloat(document.getElementById('col_h').value);
            const initNx = parseInt(document.getElementById('nz_bars').value);
            for(let i=0; i<50; i++) {
                if(!lockDim) {
                    const newB = Math.max(30, initB + (Math.floor(Math.random()*5)-2)*5);
                    const newH = Math.max(30, initH + (Math.floor(Math.random()*5)-2)*5);
                    document.getElementById('col_b').value = newB;
                    document.getElementById('col_h').value = newH;
                }
                if(!lockBar) {
                    const newNx = Math.max(2, Math.min(8, initNx + (Math.floor(Math.random()*3)-1)));
                    document.getElementById('nz_bars').value = newNx;
                    document.getElementById('nx_bars').value = newNx; 
                }
                updateApp();
                const maxDC = parseFloat(document.getElementById('dc-val').innerText);
                const b = parseFloat(document.getElementById('col_b').value);
                const h = parseFloat(document.getElementById('col_h').value);
                const nz = parseInt(document.getElementById('nz_bars').value);
                let cost = b * h;
                if (maxDC > 0.95) cost *= 1000; 
                if (cost < bestCost && maxDC <= 0.95) {
                    bestCost = cost;
                    bestConfig = { b, h, nz };
                }
                await new Promise(r => setTimeout(r, 10)); 
            }
            if(bestConfig.b) {
                document.getElementById('col_b').value = bestConfig.b;
                document.getElementById('col_h').value = bestConfig.h;
                document.getElementById('nz_bars').value = bestConfig.nz;
                document.getElementById('nx_bars').value = bestConfig.nz;
                updateApp();
                status.innerText = t('opt_done');
                status.className = "text-[10px] text-center text-green-600 font-bold h-3";
            } else {
                document.getElementById('col_b').value = initB;
                document.getElementById('col_h').value = initH;
                document.getElementById('nz_bars').value = initNx;
                updateApp();
                status.innerText = t('opt_fail');
                status.className = "text-[10px] text-center text-red-500 h-3";
            }
            btn.disabled = false;
        }
        function getCurveAtAngle(thetaRad) {
            const numPoints = 60; 
            const curve = [];
            const b = parseFloat(document.getElementById('col_b').value);
            const h = parseFloat(document.getElementById('col_h').value);
            const fc = parseFloat(document.getElementById('mat_fc').value);
            const fy = parseFloat(document.getElementById('mat_fy').value);
            let angle = thetaRad % (2*Math.PI);
            if(angle < 0) angle += 2*Math.PI;
            const numAngles = 72; 
            const step = (2*Math.PI) / numAngles;
            const idx1 = Math.floor(angle / step) % numAngles;
            const idx2 = (idx1 + 1) % numAngles;
            const ratio = (angle - (idx1 * step)) / step;
            if(!window.latestCalcData || !window.latestCalcData.curves) return [];
            const c1 = window.latestCalcData.curves[idx1];
            const c2 = window.latestCalcData.curves[idx2];
            for(let i=0; i<c1.length; i++) {
                const p1 = c1[i];
                const p2 = c2[i];
                const phiPn = p1.phiPn + ratio * (p2.phiPn - p1.phiPn);
                const M1 = Math.sqrt(p1.phiMnz**2 + p1.phiMnx**2);
                const M2 = Math.sqrt(p2.phiMnz**2 + p2.phiMnx**2);
                const M = M1 + ratio * (M2 - M1);
                curve.push({P: phiPn, M: M});
            }
            return curve;
        }
        function drawInteractionChart(curve, Pu, Mu, width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, width, height);
            const pad = 40;
            const w = width - 2*pad;
            const h = height - 2*pad;
            let maxP = -Infinity, minP = Infinity, maxM = 0;
            curve.forEach(pt => {
                if(pt.P > maxP) maxP = pt.P;
                if(pt.P < minP) minP = pt.P;
                if(pt.M > maxM) maxM = pt.M;
            });
            if(Pu > maxP) maxP = Pu;
            if(Pu < minP) minP = Pu;
            if(Mu > maxM) maxM = Mu;
            maxP += (maxP - minP) * 0.1;
            minP -= (maxP - minP) * 0.1;
            maxM *= 1.1;
            if(maxM === 0) maxM = 10; 
            const rangeP = maxP - minP;
            const scaleX = w / maxM;
            const scaleY = h / rangeP;
            const toX = (m) => pad + m * scaleX;
            const toY = (p) => pad + h - (p - minP) * scaleY;
            ctx.strokeStyle = "#cbd5e1";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(toX(0), toY(minP)); ctx.lineTo(toX(0), toY(maxP));
            const yZero = (minP <= 0 && maxP >= 0) ? 0 : minP;
            ctx.moveTo(toX(0), toY(yZero)); ctx.lineTo(toX(maxM), toY(yZero));
            ctx.stroke();
            ctx.fillStyle = "#64748b";
            ctx.font = "10px Arial";
            ctx.textAlign = "right"; ctx.fillText("P (tf)", toX(0) - 5, toY(maxP));
            ctx.textAlign = "left"; ctx.fillText("M (tf-m)", toX(maxM) + 5, toY(yZero));
            ctx.strokeStyle = "#0e7490"; 
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(toX(curve[0].M), toY(curve[0].P));
            for(let i=1; i<curve.length; i++) {
                ctx.lineTo(toX(curve[i].M), toY(curve[i].P));
            }
            ctx.stroke();
            ctx.fillStyle = "rgba(14, 116, 144, 0.1)";
            ctx.lineTo(toX(0), toY(curve[curve.length-1].P)); 
            ctx.lineTo(toX(0), toY(curve[0].P)); 
            ctx.fill();
            const ptX = toX(Mu);
            const ptY = toY(Pu);
            ctx.strokeStyle = "#94a3b8";
            ctx.setLineDash([4, 2]);
            ctx.beginPath();
            ctx.moveTo(toX(0), toY(0)); 
            ctx.lineTo(ptX, ptY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = "#dc2626"; 
            ctx.beginPath();
            ctx.arc(ptX, ptY, 4, 0, 2*Math.PI);
            ctx.fill();
            ctx.fillStyle = "black";
            ctx.font = "bold 10px Arial";
            ctx.textAlign = "left";
            ctx.fillText(`(${Mu.toFixed(1)}, ${Pu.toFixed(1)})`, ptX + 6, ptY);
            return canvas.toDataURL("image/png");
        }
        window.printReport = function() {
            const getVal = (id) => {
                const el = document.getElementById(id);
                return el ? el.value : '';
            };
            const getText = (id) => {
                const el = document.getElementById(id);
                return el ? el.innerText : '';
            };
            const I = {
                shape: getVal('col_shape'),
                legs_circ: getVal('shear_legs_circ'),
                circ_type: document.querySelector('input[name="circ_type"]:checked')?.value || 'hoop',
                b: getVal('col_b'), 
                h: getVal('col_h'), 
                cover: getVal('col_cover'),
                fc: getVal('mat_fc'), 
                fy: getVal('mat_fy'),
                lu: getVal('col_lu'),
                bar: getVal('bar_size'), 
                bar_text: document.getElementById('bar_size') ? document.getElementById('bar_size').options[document.getElementById('bar_size').selectedIndex].text : '',
                nz: getVal('nz_bars'), 
                nx: getVal('nx_bars'),
                n_circ: getVal('n_circ_bars'),
                mode: document.querySelector('input[name="rebar_mode"]:checked').value,
                custom_count: document.querySelectorAll('#table-rebar tbody tr').length,
                Pu: getVal('global_vux') ? getText('disp_pu') : "-", 
                Muy: getText('disp_mux'), 
                Muz: getText('disp_muy'),
                vuy: document.getElementById('global_vux').value, 
                vuz: document.getElementById('global_vuy').value, 
                s_tie: getVal('shear_s'), 
                db_tie: getVal('shear_db'),
                legs_z: getVal('shear_nz'), 
                legs_x: getVal('shear_nx')  
            };
            const R = {
                dc: getText('dc-val'),
                status: getText('safety-msg'),
                phiPn: getText('max_phi_pn'),
                phiMny: getText('max_phi_mnz'),
                phiMnz: getText('max_phi_mnx'),
                warnings: document.getElementById('code-warnings').innerHTML
            };
            const canvas = document.getElementById('section-canvas');
            const imgData = canvas.toDataURL("image/png");
            const dateStr = new Date().toLocaleDateString();
            const appOpt = document.getElementById('rpt_appendix').value;
            let appendixHTML = "";
            if (appOpt !== 'none') {
                renderer.render(scene, camera); 
                const img3D = renderer.domElement.toDataURL("image/png");
                appendixHTML += `
                    <div class="page-break"></div>
                    <h3>${t('rpt_app_title')}</h3>
                    <div style="border: 1px solid #ccc; padding: 10px; margin-bottom: 20px; text-align: center;">
                        <h4 style="margin: 0 0 10px 0; color: #555;">${t('rpt_3d_view')}</h4>
                        <img src="${img3D}" style="max-width: 100%; max-height: 400px; border: 1px solid #eee;">
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                `;
                const loadRows = document.querySelectorAll('#table-loads tbody tr');
                let count = 0;
                const limit = appOpt === 'summary' ? 5 : 9999;
                Array.from(loadRows).forEach((row, idx) => {
                    if (count >= limit) return;
                    const inputs = row.querySelectorAll('input');
                    const Pu = parseFloat(inputs[0].value) || 0;
                    const Muy = parseFloat(inputs[1].value) || 0; 
                    const Muz = parseFloat(inputs[2].value) || 0; 
                    const Mu_res = Math.sqrt(Muz**2 + Muy**2);
                    let angleRad = Math.atan2(Muz, Muy); 
                    const curve = getCurveAtAngle(angleRad);
                    if (curve.length > 0) {
                        const chartImg = drawInteractionChart(curve, Pu, Mu_res, 350, 350);
                        const angleDeg = (angleRad * 180 / Math.PI).toFixed(1);
                        appendixHTML += `
                            <div style="border: 1px solid #eee; padding: 10px; page-break-inside: avoid;">
                                <div style="font-size: 9pt; font-weight: bold; border-bottom: 1px solid #eee; margin-bottom: 5px; padding-bottom: 2px;">
                                    #${idx+1}: Pu=${Pu}, My=${Muy}, Mz=${Muz} (θ=${angleDeg}°)
                                </div>
                                <img src="${chartImg}" style="width: 100%; height: auto;">
                            </div>
                        `;
                        count++;
                    }
                });
                appendixHTML += `</div>`;
            }
            let legsDisplayHTML = "";
            if (I.shape === 'circ') {
                const typeKey = I.circ_type === 'spiral' ? 'lbl_spiral' : 'lbl_hoop';
                const typeText = t(typeKey);
                legsDisplayHTML = `${I.legs_circ} (${t('lbl_legs_circ')}) - <strong>${typeText}</strong>`;
            } else {
                legsDisplayHTML = `Z: ${I.legs_z} ${t('rpt_legs_d')} / X: ${I.legs_x} ${t('rpt_legs_w')}`;
            }
            let shearTableRows = "";
            const Ag = (I.shape === 'rect') ? (parseFloat(I.b) * parseFloat(I.h)) : (Math.PI * Math.pow(parseFloat(I.b)/2, 2));
            const fc = parseFloat(I.fc);
            const fy = parseFloat(I.fy);
            const db_tie = parseFloat(I.db_tie);
            const s_tie = parseFloat(I.s_tie);
            const cover = parseFloat(I.cover);
            const Av_tie = Math.PI * Math.pow(db_tie/2, 2);
            const calcShearCap = (bw, d, legs, Pu_val) => {
                const Nu_kg = Pu_val * 1000; 
                let Vc = 0;
                if (Nu_kg >= 0) {
                    const term_axial = 1 + (Nu_kg / (140 * Ag));
                    const stress_vc = 0.53 * Math.sqrt(fc) * term_axial;
                    Vc = stress_vc * bw * d; 
                } else {
                    Vc = 0;
                }
                const isSeismic = document.getElementById('seismic_mode').checked;
                if (isSeismic && Nu_kg < (Ag * fc) / 20) {
                    Vc = 0;
                }
                const Vs = (legs * Av_tie * fy * d) / s_tie; 
                const Vs_max = 2.12 * Math.sqrt(fc) * bw * d; 
                const Vn = Vc + Math.min(Vs, Vs_max);
                const phi = 0.75;
                return (phi * Vn) / 1000; 
            };
            const Vuy_demand = Math.abs(parseFloat(I.vuy) || 0);
            const Vuz_demand = Math.abs(parseFloat(I.vuz) || 0);
            const Pu_calc = parseFloat(I.Pu) || 0; 
            if (I.shape === 'circ') {
                const D = parseFloat(I.b);
                const d_eff = 0.8 * D;
                const legs = parseFloat(I.legs_circ);
                const Vu_res = Math.sqrt(Vuy_demand**2 + Vuz_demand**2);
                const phiVn = calcShearCap(D, d_eff, legs, Pu_calc);
                const ratio = phiVn > 0 ? (Vu_res / phiVn) : 999;
                const status = ratio <= 1.0 ? `<span class="pass">OK</span>` : `<span class="fail">FAIL</span>`;
                shearTableRows = `
                    <tr>
                        <td><strong>${t('rpt_res')}</strong></td>
                        <td>${Vu_res.toFixed(2)} tf</td>
                        <td>${I.legs_circ} (${t('lbl_legs_circ')})</td>
                        <td>ϕVn=${phiVn.toFixed(2)} tf <br> (D/C: ${ratio.toFixed(2)}) ${status}</td>
                    </tr>
                `;
            } else {
                const h_dim = parseFloat(I.h); 
                const b_dim = parseFloat(I.b); 
                const bar_db = I.bar > 0 ? Math.sqrt(parseFloat(I.bar) * 4 / Math.PI) : 1.27;
                const d_y = b_dim - cover - db_tie - bar_db/2; 
                const d_z = h_dim - cover - db_tie - bar_db/2; 
                const legs_y = parseFloat(I.legs_x); 
                const phiVny = calcShearCap(h_dim, d_y, legs_y, Pu_calc);
                const ratio_y = phiVny > 0 ? (Vuy_demand / phiVny) : 999;
                const status_y = ratio_y <= 1.0 ? `<span class="pass">OK</span>` : `<span class="fail">FAIL</span>`;
                const legs_z = parseFloat(I.legs_z); 
                const phiVnz = calcShearCap(b_dim, d_z, legs_z, Pu_calc);
                const ratio_z = phiVnz > 0 ? (Vuz_demand / phiVnz) : 999;
                const status_z = ratio_z <= 1.0 ? `<span class="pass">OK</span>` : `<span class="fail">FAIL</span>`;
                shearTableRows = `
                    <tr>
                        <td><strong>${t('rpt_xdir')}</strong></td> <td>${Vuy_demand.toFixed(2)} tf</td>
                        <td>${legs_y} ${t('rpt_legs_w')}</td>
                        <td>ϕVn=${phiVny.toFixed(2)} tf <br> (D/C: ${ratio_y.toFixed(2)}) ${status_y}</td>
                    </tr>
                    <tr>
                        <td><strong>${t('rpt_ydir')}</strong></td> <td>${Vuz_demand.toFixed(2)} tf</td>
                        <td>${legs_z} ${t('rpt_legs_d')}</td>
                        <td>ϕVn=${phiVnz.toFixed(2)} tf <br> (D/C: ${ratio_z.toFixed(2)}) ${status_z}</td>
                    </tr>
                `;
            }
            let dimDisplay = "";
            if (I.shape === 'circ') {
                dimDisplay = `D = ${I.b} cm`;
            } else {
                dimDisplay = `${I.b} x ${I.h} cm`;
            }
            let confDisplay = "";
            if (I.mode === 'custom') {
                confDisplay = `${t('lbl_cust')} (${I.custom_count} ${t('rpt_bars')})`;
            } else {
                if (I.shape === 'circ') {
                    confDisplay = `${I.n_circ || 0} ${t('rpt_bars')}`; 
                } else {
                    confDisplay = `${I.nz} x ${I.nx} ${t('rpt_bars')}`;
                }
            }
            let html = `
                <div class="rpt-header">
                    <div>
                        <h1 class="rpt-title">${t('rpt_title')}</h1>
                        <p class="rpt-subtitle">${t('rpt_sub')}</p>
                    </div>
                    <div>${dateStr}</div>
                </div>
                <h3>${t('rpt_sec1')}</h3>
                <div style="display: flex; gap: 20px; align-items: flex-start; margin-bottom: 20px;">
                    <div style="flex: 0 0 150px; border: 1px solid #ccc; padding: 10px; text-align: center;">
                        <img src="${imgData}" style="width: 100%; height: auto;">
                        <p style="font-size: 8pt; color: #666; margin-top: 5px;">Section View</p>
                    </div>
                    <div style="flex: 1;">
                        <table>
                            <tr><th colspan="4">${t('rpt_geo_mat')}</th></tr>
                            <tr>
                                <td width="25%"><strong>${t('rpt_dim')}</strong></td>
                                <td width="25%">${dimDisplay}</td>
                                <td width="25%"><strong>${t('rpt_con')}</strong></td>
                                <td width="25%">${I.fc} kgf/cm²</td>
                            </tr>
                            <tr>
                                <td><strong>${t('rpt_cov')}</strong></td>
                                <td>${I.cover} cm</td>
                                <td><strong>${t('rpt_st')}</strong></td>
                                <td>${I.fy} kgf/cm²</td>
                            </tr>
                            <tr>
                                <td><strong>${t('rpt_len')}</strong></td>
                                <td>${I.lu} m</td>
                                <td><strong>${t('rpt_mod')}</strong></td>
                                <td>${I.mode === 'regular' ? t('lbl_reg') : t('lbl_cust')}</td>
                            </tr>
                        </table>
                    </div>
                </div>
                <table>
                    <tr><th colspan="4">${t('rpt_reinf_det')}</th></tr>
                    <tr>
                        <td><strong>${t('rpt_main')}</strong></td>
                        <td>${I.bar_text}</td>
                        <td><strong>${t('rpt_conf')}</strong></td>
                        <td>${confDisplay}</td>
                    </tr>
                    <tr>
                        <td><strong>${t('rpt_tie')}</strong></td>
                        <td>D${(parseFloat(I.db_tie)*10).toFixed(0)} (d=${I.db_tie}cm)</td>
                        <td><strong>${t('rpt_tie_sp')}</strong></td>
                        <td>@ ${I.s_tie} cm</td>
                    </tr>
                      <tr>
                        <td><strong>${t('rpt_legs')}</strong></td>
                        <td colspan="3">${legsDisplayHTML}</td>
                    </tr>
                </table>
                <h3>${t('rpt_sec2')}</h3>
                <table>
                    <tr>
                        <th>${t('rpt_param')}</th>
                        <th>${t('rpt_app')}</th>
                        <th>${t('rpt_lim')}</th>
                        <th>${t('rpt_chk')}</th>
                    </tr>
                    <tr>
                        <td><strong>${t('rpt_ax')}</strong></td>
                        <td>${I.Pu} tf</td>
                        <td>ϕPn(max) = ${R.phiPn} tf</td>
                        <td rowspan="3" style="text-align:center; font-size:12pt;">
                            <strong>${t('rpt_dc')}</strong><br>
                            <span style="font-size: 16pt; color: ${parseFloat(R.dc) > 1 ? '#dc2626' : '#15803d'}">${R.dc}</span>
                        </td>
                    </tr>
                    <tr>
                        <td><strong>${t('rpt_mx')}</strong></td> <!-- Muy -->
                        <td>${I.Muy} tf-m</td>
                        <td>ϕMny(max) = ${R.phiMny} tf-m</td>
                    </tr>
                    <tr>
                        <td><strong>${t('rpt_my')}</strong></td> <!-- Muz -->
                        <td>${I.Muz} tf-m</td>
                        <td>ϕMnz(max) = ${R.phiMnz} tf-m</td>
                    </tr>
                </table>
                <div style="background: ${parseFloat(R.dc) > 1 ? '#fee2e2' : '#dcfce7'}; padding: 10px; border-radius: 4px; text-align: center; font-weight: bold; color: ${parseFloat(R.dc) > 1 ? '#991b1b' : '#166534'}; margin-bottom: 20px;">
                    ${t('rpt_stat')}: ${R.status}
                </div>
                <h3>${t('rpt_sec3')}</h3>
                <table>
                    <tr>
                        <th>${t('rpt_dir')}</th>
                        <th>${t('rpt_dem')}</th>
                        <th>${t('rpt_prov')}</th>
                        <th>${t('rpt_cap_chk')}</th>
                    </tr>
                    ${shearTableRows}
                </table>
                <h3>${t('rpt_sec4')}</h3>
                <div style="border: 1px solid #e2e8f0; padding: 10px; border-radius: 4px;">
                    ${R.warnings || `<p style="color:#64748b; font-style:italic;">${t('rpt_no_warn')}</p>`}
                </div>
                ${appendixHTML} <div style="margin-top: 30px; border-top: 1px solid #ccc; padding-top: 5px; font-size: 8pt; text-align: center; color: #888;">
                    ${t('rpt_footer')} | ${new Date().getFullYear()}
                </div>
            `;
            const staging = document.getElementById('print-staging');
            staging.innerHTML = html;
            setTimeout(() => {
                window.print();
            }, 500);
        }
    </script>
</body>
